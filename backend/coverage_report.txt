============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/brunogandolfo/cfo-inteligente/backend
configfile: pytest.ini
plugins: asyncio-1.2.0, timeout-2.4.0, cov-7.0.0, mock-3.15.1, anyio-4.10.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 560 items

tests/test_ai_components.py .........FF                                  [  1%]
tests/test_ai_orchestrator.py ...........................                [  6%]
tests/test_auth_endpoints.py .....FFFFFF..FFFFFFF                        [ 10%]
tests/test_calculators.py ...............                                [ 13%]
tests/test_charts.py ...............                                     [ 15%]
tests/test_claude_sql_generator.py FF.F..FFFFFFF.......FF.F......        [ 21%]
tests/test_conversacion_service.py ......................                [ 25%]
tests/test_date_resolver.py ..........                                   [ 26%]
tests/test_e2e.py EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEExxxx [ 36%]
xxxXXXxEEE.                                                              [ 38%]
tests/test_formatters.py ..................                              [ 41%]
tests/test_integration.py F.FFFFFFFFFFFFFFF..FFFF.FFFFF..FFFF            [ 47%]
tests/test_integration_real.py F..FFEEEEE...EE.EE                        [ 51%]
tests/test_metrics_aggregator.py FFFFF                                   [ 51%]
tests/test_monthly_aggregator.py ....FFF                                 [ 53%]
tests/test_operacion_service.py ......EEEEEEEFFFFEEEEE..E....EF.         [ 58%]
tests/test_query_fallback.py .........................                   [ 63%]
tests/test_security.py ..............F...                                [ 66%]
tests/test_sql_post_processor.py .............................           [ 71%]
tests/test_sql_router.py .............................F......            [ 78%]
tests/test_stats_calculator.py ..........                                [ 80%]
tests/test_tipo_cambio_service.py ......................                 [ 83%]
tests/test_validador_sql.py ............................................ [ 91%]
...................................                                      [ 98%]
tests/test_validators.py ...........                                     [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto facturamos este mes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb05ae030>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo viene la rentabilidad?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb05711f0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l es el margen de este mes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0572ed0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfEstamos mejor que el mes pasado?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0573d10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo vamos en el a\xf1o?] ___

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0525f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto ganamos este trimestre?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0524e00>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l es la rentabilidad del \xe1rea Jur\xeddi] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0569b50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea es m\xe1s rentable?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0568440>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo est\xe1 la rentabilidad de Notarial?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0542510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
______ ERROR at setup of test_pregunta_real_e2e[Dame un resumen del mes] _______

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb056ba10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l fue el mejor mes del a\xf1o?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0599550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfVenimos mejorando la rentabilidad?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059ba10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto es el resultado operativo?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb94f6990>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo viene el margen comparado con el a] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb954f1d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfProyectamos bien el cierre de a\xf1o?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb95e1100>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto le toca a Bruno este a\xf1o?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0568ec0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto recibi\xf3 Agustina en distribucion] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb95e1790>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 socio retir\xf3 m\xe1s plata?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb94f44d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1ndo fue la \xfaltima distribuci\xf3n?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059bbf0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto se distribuy\xf3 este trimestre?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0598ec0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfEst\xe1n bien los porcentajes de cada soci] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb056a6f0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto llev\xf3 Viviana en el a\xf1o?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb050dc40>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 socio tiene m\xe1s retiros?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059a690>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto se reparti\xf3 en total?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059a1e0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfGonzalo est\xe1 recibiendo lo que correspo] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb94f6600>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfFacturamos m\xe1s este mes que el anterior] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb95e1430>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo se compara este trimestre con el p] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb050eba0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of test_pregunta_real_e2e[\xbfEstamos creciendo o bajando?] __

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb05242c0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 trimestre fue mejor?] ___

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9539e80>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo va octubre comparado con septiembr] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb954f4d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfMejoramos respecto al a\xf1o pasado?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb056ac90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
____ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l fue el peor mes?] ____

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059aab0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfLa tendencia es positiva o negativa?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0524e90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
___ ERROR at setup of test_pregunta_real_e2e[\xbfEstamos en alza o en baja?] ___

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057fb30>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo viene la facturaci\xf3n mes a mes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0599fa0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto facturamos en d\xf3lares este mes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb056b6e0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto gastamos en pesos?] __

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb94f5550>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 porcentaje de facturaci\xf3n es en USD] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb95e3080>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto se distribuy\xf3 en d\xf3lares?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057ce30>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfOperamos m\xe1s en pesos o d\xf3lares?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057d220>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l es el tipo de cambio promedio que ] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb050f080>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea factura m\xe1s en d\xf3lares?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb056a090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto es todo en d\xf3lares?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb059a090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea genera m\xe1s ingresos?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057fc80>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto factura Montevideo vs Mercedes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb05700b0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 oficina es m\xe1s rentable?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0573e60>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfC\xf3mo est\xe1 Mercedes este mes?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057f890>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1nto gast\xf3 Contable?] __

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0599340>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea tiene m\xe1s gastos?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb95e37d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_ ERROR at setup of test_pregunta_real_e2e[\xbfCu\xe1l es la facturaci\xf3n de cada \xe1rea?] _

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9538710>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_____ ERROR at setup of TestMetricasPrecision.test_tasa_respuesta_exitosa ______

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0540080>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__ ERROR at setup of TestMetricasPrecision.test_metadata_presente_en_exitosas __

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb057ca10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
___ ERROR at setup of TestMetricasPrecision.test_tiempo_respuesta_razonable ____

    @pytest.fixture
    def mock_claude_apis():
        """Mock de ambos usos de Claude (SQL + Narrativa)"""
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_sql:
>           with patch('app.api.cfo_ai.client') as mock_narrativa:

tests/test_e2e.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0598ce0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
___ ERROR at setup of TestOperacionesIntegration.test_crear_ingreso_completo ___

db_session = <sqlalchemy.orm.session.Session object at 0x7fafa4732060>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafa4788d10>
kwargs = {'id': UUID('3a6811d6-86dc-4489-afd9-b2b523546a0d'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
____ ERROR at setup of TestOperacionesIntegration.test_crear_gasto_completo ____

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb94fc110>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb9148c20>
kwargs = {'id': UUID('05d6260e-1425-4aaf-a724-0a8da3af2276'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
___ ERROR at setup of TestOperacionesIntegration.test_crear_retiro_completo ____

db_session = <sqlalchemy.orm.session.Session object at 0x7fafa478bf80>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb9149430>
kwargs = {'id': UUID('60511734-81d1-48db-b5f1-a9093fbb3a9d'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
_ ERROR at setup of TestOperacionesIntegration.test_operacion_calcula_monto_usd_correctamente _

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb954f8f0>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb05310d0>
kwargs = {'id': UUID('f7ba4fc3-c70a-4a06-8e63-1c68a83f1165'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
_ ERROR at setup of TestOperacionesIntegration.test_listar_operaciones_con_filtros _

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0530a10>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb914a1b0>
kwargs = {'id': UUID('15b3760e-6d5d-4735-9187-436cdf5a6dba'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
_ ERROR at setup of TestCFOAIIntegration.test_pregunta_simple_retorna_respuesta _

db_session = <sqlalchemy.orm.session.Session object at 0x7fafa4789310>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb91bb7d0>
kwargs = {'id': UUID('62a9dfb8-ee97-40e0-b8a7-43d11ef34c1d'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
____ ERROR at setup of TestCFOAIIntegration.test_pregunta_genera_sql_valido ____

db_session = <sqlalchemy.orm.session.Session object at 0x7fafa4788410>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb0201100>
kwargs = {'id': UUID('8835899d-e067-4052-b48c-b9ce00cd0bb6'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
______ ERROR at setup of TestDatosConsistencia.test_soft_delete_operacion ______

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb056ba40>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb91bbd40>
kwargs = {'id': UUID('46af2c0e-0099-48bf-b408-433d2d9f6bcb'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
_____ ERROR at setup of TestDatosConsistencia.test_relacion_operacion_area _____

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0560230>

    @pytest.fixture
    def setup_datos_base(db_session):
        """Crea datos base necesarios: reas y socios"""
        # Crear reas
        areas = [
            Area(id=uuid4(), nombre="Jurdica", activo=True),
            Area(id=uuid4(), nombre="Notarial", activo=True),
            Area(id=uuid4(), nombre="Gastos Generales", activo=True),
            Area(id=uuid4(), nombre="Inmobiliaria", activo=True),
        ]
        db_session.add_all(areas)
    
        # Crear socios
        socios = [
>           Socio(id=uuid4(), nombre="Agustina", porcentaje=Decimal("20.00")),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Socio(id=uuid4(), nombre="Viviana", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Gonzalo", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Pancho", porcentaje=Decimal("20.00")),
            Socio(id=uuid4(), nombre="Bruno", porcentaje=Decimal("20.00")),
        ]

tests/test_integration_real.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:571: in _initialize_instance
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.models.socio.Socio object at 0x7fafb0524650>
kwargs = {'id': UUID('2de194c1-77fd-490c-af73-5d2268d280a5'), 'nombre': 'Agustina', 'porcentaje': Decimal('20.00')}
cls_ = <class 'app.models.socio.Socio'>, k = 'porcentaje'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'porcentaje' is an invalid keyword argument for Socio

venv/lib/python3.12/site-packages/sqlalchemy/orm/decl_base.py:2167: TypeError
__ ERROR at setup of TestCrearOperacionBase.test_crear_operacion_base_ingreso __

self = <sqlalchemy.engine.base.Connection object at 0x7fafa4733470>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4731af0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9148980>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafa4732f30>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4731af0>
cursor = <cursor object at 0x7fafb05fa200; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9148980>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafa47303b0>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4731af0>
cursor = <cursor object at 0x7fafb05fa200; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9148980>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
___ ERROR at setup of TestCrearOperacionBase.test_crear_operacion_base_gasto ___

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0201790>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb985d0a0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02019a0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0203e60>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb985d0a0>
cursor = <cursor object at 0x7fafb03413f0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02019a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb9149a30>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb985d0a0>
cursor = <cursor object at 0x7fafb03413f0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02019a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearOperacionBase.test_crear_operacion_base_localidad_normalizada _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0202b70>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0200ad0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0200290>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb02025a0>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0200ad0>
cursor = <cursor object at 0x7fafa47a0e50; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0200290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0200f20>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0200ad0>
cursor = <cursor object at 0x7fafa47a0e50; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0200290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________ ERROR at setup of TestCrearIngreso.test_crear_ingreso_uyu ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0202ae0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0201790>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0203fe0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0203590>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0201790>
cursor = <cursor object at 0x7fafb95775b0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0203fe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb02032f0>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0201790>
cursor = <cursor object at 0x7fafb95775b0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0203fe0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________ ERROR at setup of TestCrearIngreso.test_crear_ingreso_usd ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb02cc980>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02cfe60>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02cd070>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb02cc6e0>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02cfe60>
cursor = <cursor object at 0x7fafb94a88b0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02cd070>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb02ce450>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02cfe60>
cursor = <cursor object at 0x7fafb94a88b0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb02cd070>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
____________ ERROR at setup of TestCrearGasto.test_crear_gasto_uyu _____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb02032f0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02012e0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9457620>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0200230>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02012e0>
cursor = <cursor object at 0x7fafb05fa5c0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9457620>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb02cdfd0>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02012e0>
cursor = <cursor object at 0x7fafb05fa5c0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9457620>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
____________ ERROR at setup of TestCrearGasto.test_crear_gasto_usd _____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9454b30>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9455760>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94544d0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb9456030>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9455760>
cursor = <cursor object at 0x7fafb94aaa70; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94544d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb94554f0>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9455760>
cursor = <cursor object at 0x7fafb94aaa70; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94544d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearDistribucion.test_crear_distribucion_5_socios_completa _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb93c7140>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c6390>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c4140>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb93c4080>
parameters = [{'nombre_1': 'Agustina', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c6390>
cursor = <cursor object at 0x7fafb949cd60; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c4140>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb93c5250>

    @pytest.fixture(scope="function")
    def socios_test(db_session):
        """Fixture que retorna los 5 socios del sistema"""
        socios = {}
        for nombre in ['Agustina', 'Viviana', 'Gonzalo', 'Pancho', 'Bruno']:
>           socio = db_session.query(Socio).filter(Socio.nombre == nombre).first()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c6390>
cursor = <cursor object at 0x7fafb949cd60; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c4140>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^
E       
E       [SQL: SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_participacion, socios.activo AS socios_activo, socios.created_at AS socios_created_at, socios.updated_at AS socios_updated_at 
E       FROM socios 
E       WHERE socios.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Agustina', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearDistribucion.test_crear_distribucion_parcial_3_socios _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9456ff0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414ce0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9456f30>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb9454a70>
parameters = [{'nombre_1': 'Agustina', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414ce0>
cursor = <cursor object at 0x7fafb94a9e40; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9456f30>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb9416e70>

    @pytest.fixture(scope="function")
    def socios_test(db_session):
        """Fixture que retorna los 5 socios del sistema"""
        socios = {}
        for nombre in ['Agustina', 'Viviana', 'Gonzalo', 'Pancho', 'Bruno']:
>           socio = db_session.query(Socio).filter(Socio.nombre == nombre).first()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414ce0>
cursor = <cursor object at 0x7fafb94a9e40; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9456f30>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^
E       
E       [SQL: SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_participacion, socios.activo AS socios_activo, socios.created_at AS socios_created_at, socios.updated_at AS socios_updated_at 
E       FROM socios 
E       WHERE socios.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Agustina', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearDistribucion.test_crear_distribucion_detecta_moneda_original _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb93c7500>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c7230>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb96d0380>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb93c5eb0>
parameters = [{'nombre_1': 'Agustina', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c7230>
cursor = <cursor object at 0x7fafb9609210; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb96d0380>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb93c4710>

    @pytest.fixture(scope="function")
    def socios_test(db_session):
        """Fixture que retorna los 5 socios del sistema"""
        socios = {}
        for nombre in ['Agustina', 'Viviana', 'Gonzalo', 'Pancho', 'Bruno']:
>           socio = db_session.query(Socio).filter(Socio.nombre == nombre).first()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c7230>
cursor = <cursor object at 0x7fafb9609210; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb96d0380>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^
E       
E       [SQL: SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_participacion, socios.activo AS socios_activo, socios.created_at AS socios_created_at, socios.updated_at AS socios_updated_at 
E       FROM socios 
E       WHERE socios.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Agustina', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearDistribucion.test_crear_distribucion_no_requiere_area _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0552870>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553800>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057d1c0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0524ef0>
parameters = [{'nombre_1': 'Agustina', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553800>
cursor = <cursor object at 0x7fafb94a87c0; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057d1c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0550da0>

    @pytest.fixture(scope="function")
    def socios_test(db_session):
        """Fixture que retorna los 5 socios del sistema"""
        socios = {}
        for nombre in ['Agustina', 'Viviana', 'Gonzalo', 'Pancho', 'Bruno']:
>           socio = db_session.query(Socio).filter(Socio.nombre == nombre).first()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553800>
cursor = <cursor object at 0x7fafb94a87c0; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057d1c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^
E       
E       [SQL: SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_participacion, socios.activo AS socios_activo, socios.created_at AS socios_created_at, socios.updated_at AS socios_updated_at 
E       FROM socios 
E       WHERE socios.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Agustina', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestCrearDistribucion.test_crear_distribucion_porcentaje_20 _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb91b8a10>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb91b9e20>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbc20>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb91bae10>
parameters = [{'nombre_1': 'Agustina', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb91b9e20>
cursor = <cursor object at 0x7fafb0340c70; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbc20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0541220>

    @pytest.fixture(scope="function")
    def socios_test(db_session):
        """Fixture que retorna los 5 socios del sistema"""
        socios = {}
        for nombre in ['Agustina', 'Viviana', 'Gonzalo', 'Pancho', 'Bruno']:
>           socio = db_session.query(Socio).filter(Socio.nombre == nombre).first()
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb91b9e20>
cursor = <cursor object at 0x7fafb0340c70; closed: -1>
statement = 'SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_p...ted_at, socios.updated_at AS socios_updated_at \nFROM socios \nWHERE socios.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Agustina', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbc20>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 2: FROM socios 
E                    ^
E       
E       [SQL: SELECT socios.id AS socios_id, socios.nombre AS socios_nombre, socios.porcentaje_participacion AS socios_porcentaje_participacion, socios.activo AS socios_activo, socios.created_at AS socios_created_at, socios.updated_at AS socios_updated_at 
E       FROM socios 
E       WHERE socios.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Agustina', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
________ ERROR at setup of TestCasosEdge.test_crear_ingreso_sin_cliente ________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0551dc0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edcfe0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553080>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0553a70>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edcfe0>
cursor = <cursor object at 0x7fafb94aa4d0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553080>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb1edd580>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edcfe0>
cursor = <cursor object at 0x7fafb94aa4d0; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553080>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_ ERROR at setup of TestFiltrosPorLocalidadArea.test_crear_operaciones_diferentes_localidades _

self = <sqlalchemy.engine.base.Connection object at 0x7fafb02000b0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02011f0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0202030>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0200b30>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02011f0>
cursor = <cursor object at 0x7fafb1e46110; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0202030>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x7fafb02020f0>

    @pytest.fixture(scope="function")
    def area_test(db_session):
        """Fixture que retorna un rea de prueba"""
>       area = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb02011f0>
cursor = <cursor object at 0x7fafb1e46110; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0202030>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
=================================== FAILURES ===================================
__________________ test_fallback_estrategico_genera_insights ___________________

    def test_fallback_estrategico_genera_insights():
        """Test: Fallback estratgico genera insights."""
        metricas = {
            'ingresos_uyu': 500000.0,
            'rentabilidad_neta': 35.0,
            'duracion_dias': 90,
            'rentabilidad_por_area': {'Notarial': 78.5, 'Jurdica': 65.2},
            'porcentaje_ingresos_por_area': {'Notarial': 55.0, 'Jurdica': 45.0}
        }
    
>       insights = generate_estrategico_fallback(metricas)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ai_components.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

metricas = {'duracion_dias': 90, 'ingresos_uyu': 500000.0, 'porcentaje_ingresos_por_area': {'Jurdica': 45.0, 'Notarial': 55.0}, 'rentabilidad_neta': 35.0, ...}

    def generate_estrategico_fallback(metricas: Dict[str, Any]) -> Dict[str, str]:
        """
        Genera insights estratgicos sin IA.
    
        Args:
            metricas: Dict con mtricas calculadas
    
        Returns:
            Dict con 4 insights estratgicos
        """
        ingresos = float(metricas.get('ingresos_uyu', 0))
        margen_operativo = metricas.get('margen_operativo', 0.0)
        duracion_dias = metricas.get('duracion_dias', 0)
    
        rent_areas = metricas.get('rentabilidad_por_area', {})
        dist_areas = metricas.get('porcentaje_ingresos_por_area', {})
    
        # Tendencia (basada en margen)
>       if rentabilidad_neta >= 30:
           ^^^^^^^^^^^^^^^^^
E       NameError: name 'rentabilidad_neta' is not defined

app/services/ai/fallback_generator.py:118: NameError
_______________ test_fallback_estrategico_identifica_disparidad ________________

    def test_fallback_estrategico_identifica_disparidad():
        """Test: Fallback estratgico identifica disparidad en reas."""
        metricas = {
            'ingresos_uyu': 500000.0,
            'rentabilidad_neta': 35.0,
            'duracion_dias': 90,
            'rentabilidad_por_area': {'Notarial': 80.0, 'Jurdica': 40.0},  # Brecha grande
            'porcentaje_ingresos_por_area': {'Notarial': 50.0, 'Jurdica': 50.0}
        }
    
>       insights = generate_estrategico_fallback(metricas)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ai_components.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

metricas = {'duracion_dias': 90, 'ingresos_uyu': 500000.0, 'porcentaje_ingresos_por_area': {'Jurdica': 50.0, 'Notarial': 50.0}, 'rentabilidad_neta': 35.0, ...}

    def generate_estrategico_fallback(metricas: Dict[str, Any]) -> Dict[str, str]:
        """
        Genera insights estratgicos sin IA.
    
        Args:
            metricas: Dict con mtricas calculadas
    
        Returns:
            Dict con 4 insights estratgicos
        """
        ingresos = float(metricas.get('ingresos_uyu', 0))
        margen_operativo = metricas.get('margen_operativo', 0.0)
        duracion_dias = metricas.get('duracion_dias', 0)
    
        rent_areas = metricas.get('rentabilidad_por_area', {})
        dist_areas = metricas.get('porcentaje_ingresos_por_area', {})
    
        # Tendencia (basada en margen)
>       if rentabilidad_neta >= 30:
           ^^^^^^^^^^^^^^^^^
E       NameError: name 'rentabilidad_neta' is not defined

app/services/ai/fallback_generator.py:118: NameError
_______________ TestRegister.test_register_exitoso_crea_usuario ________________

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f5490>
client = (<starlette.testclient.TestClient object at 0x7fafb94fd2b0>, <Mock id='140392705027312'>)

    def test_register_exitoso_crea_usuario(self, client):
        """Registro exitoso debe crear usuario"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "nuevo@grupoconexion.uy",
            "nombre": "Nuevo Usuario",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:201: AssertionError
____________ TestRegister.test_register_email_duplicado_retorna_400 ____________

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f5670>
client = (<starlette.testclient.TestClient object at 0x7fafb94fd670>, <Mock id='140392705016656'>)
mock_usuario_activo = <Mock name='mock.query().filter().first()' id='140392705029712'>

    def test_register_email_duplicado_retorna_400(self, client, mock_usuario_activo):
        """Email duplicado debe retornar 400"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = mock_usuario_activo
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "test@grupoconexion.uy",
            "nombre": "Usuario Duplicado",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 400
E       assert 401 == 400
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:224: AssertionError
_______ TestRegister.test_register_asigna_rol_socio_si_email_autorizado ________

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f5820>
client = (<starlette.testclient.TestClient object at 0x7fafb94fd9d0>, <Mock id='140392705017664'>)

    def test_register_asigna_rol_socio_si_email_autorizado(self, client):
        """Email autorizado debe asignar es_socio=True"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Emails autorizados: aborio, falgorta, vcaresani, gtaborda
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "aborio@grupoconexion.uy",
            "nombre": "Aborio Socio",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:243: AssertionError
___ TestRegister.test_register_asigna_rol_colaborador_si_email_no_autorizado ___

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f59d0>
client = (<starlette.testclient.TestClient object at 0x7fafb94c9fd0>, <Mock id='140392704811200'>)

    def test_register_asigna_rol_colaborador_si_email_no_autorizado(self, client):
        """Email no autorizado debe asignar es_socio=False"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "colaborador@grupoconexion.uy",
            "nombre": "Colaborador Normal",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:265: AssertionError
________________ TestRegister.test_register_password_se_hashea _________________

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f5b80>
client = (<starlette.testclient.TestClient object at 0x7fafb9538d70>, <Mock id='140392705265248'>)

    def test_register_password_se_hashea(self, client):
        """El password debe guardarse hasheado, no en texto plano"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        password_plano = "mi_password_secreto"
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "nuevo@grupoconexion.uy",
            "nombre": "Nuevo Usuario",
            "password": password_plano
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:289: AssertionError
____________ TestRegister.test_register_usuario_activo_por_defecto _____________

self = <tests.test_auth_endpoints.TestRegister object at 0x7fb0601f5d30>
client = (<starlette.testclient.TestClient object at 0x7fafb94c1cd0>, <Mock id='140392704778864'>)

    def test_register_usuario_activo_por_defecto(self, client):
        """Usuario nuevo debe estar activo por defecto"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "nuevo@grupoconexion.uy",
            "nombre": "Nuevo Usuario",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:310: AssertionError
_________ TestAuthValidation.test_register_email_invalido_retorna_422 __________

self = <tests.test_auth_endpoints.TestAuthValidation object at 0x7fb0601f62a0>
client = (<starlette.testclient.TestClient object at 0x7fafb94f7170>, <Mock id='140392704985520'>)

    def test_register_email_invalido_retorna_422(self, client):
        """Register con email invlido debe retornar 422"""
        # Arrange
        test_client, mock_db = client
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "email_invalido",
            "nombre": "Test",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 422
E       assert 401 == 422
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:362: AssertionError
___________ TestAuthValidation.test_register_sin_nombre_retorna_422 ____________

self = <tests.test_auth_endpoints.TestAuthValidation object at 0x7fb0601f6450>
client = (<starlette.testclient.TestClient object at 0x7fafb94f7ce0>, <Mock id='140392704996320'>)

    def test_register_sin_nombre_retorna_422(self, client):
        """Register sin nombre debe retornar 422"""
        # Arrange
        test_client, mock_db = client
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": "test@email.com",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 422
E       assert 401 == 422
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:376: AssertionError
__ TestSociosAutorizados.test_todos_los_socios_autorizados_son_socios[aborio] __

self = <tests.test_auth_endpoints.TestSociosAutorizados object at 0x7fb0601f66c0>
client = (<starlette.testclient.TestClient object at 0x7fafb94f6ea0>, <Mock id='140392704984656'>)
prefijo = 'aborio'

    @pytest.mark.parametrize("prefijo", ["aborio", "falgorta", "vcaresani", "gtaborda"])
    def test_todos_los_socios_autorizados_son_socios(self, client, prefijo):
        """Todos los prefijos en SOCIOS_AUTORIZADOS deben crear socio"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": f"{prefijo}@grupoconexion.uy",
            "nombre": f"Socio {prefijo}",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:401: AssertionError
_ TestSociosAutorizados.test_todos_los_socios_autorizados_son_socios[falgorta] _

self = <tests.test_auth_endpoints.TestSociosAutorizados object at 0x7fb0601f6870>
client = (<starlette.testclient.TestClient object at 0x7fafb94c2e10>, <Mock id='140392704781312'>)
prefijo = 'falgorta'

    @pytest.mark.parametrize("prefijo", ["aborio", "falgorta", "vcaresani", "gtaborda"])
    def test_todos_los_socios_autorizados_son_socios(self, client, prefijo):
        """Todos los prefijos en SOCIOS_AUTORIZADOS deben crear socio"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": f"{prefijo}@grupoconexion.uy",
            "nombre": f"Socio {prefijo}",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:401: AssertionError
_ TestSociosAutorizados.test_todos_los_socios_autorizados_son_socios[vcaresani] _

self = <tests.test_auth_endpoints.TestSociosAutorizados object at 0x7fb0601f6930>
client = (<starlette.testclient.TestClient object at 0x7fafb95392e0>, <Mock id='140392705276048'>)
prefijo = 'vcaresani'

    @pytest.mark.parametrize("prefijo", ["aborio", "falgorta", "vcaresani", "gtaborda"])
    def test_todos_los_socios_autorizados_son_socios(self, client, prefijo):
        """Todos los prefijos en SOCIOS_AUTORIZADOS deben crear socio"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": f"{prefijo}@grupoconexion.uy",
            "nombre": f"Socio {prefijo}",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:401: AssertionError
_ TestSociosAutorizados.test_todos_los_socios_autorizados_son_socios[gtaborda] _

self = <tests.test_auth_endpoints.TestSociosAutorizados object at 0x7fb0601f69f0>
client = (<starlette.testclient.TestClient object at 0x7fafb94fe180>, <Mock id='140392704817056'>)
prefijo = 'gtaborda'

    @pytest.mark.parametrize("prefijo", ["aborio", "falgorta", "vcaresani", "gtaborda"])
    def test_todos_los_socios_autorizados_son_socios(self, client, prefijo):
        """Todos los prefijos en SOCIOS_AUTORIZADOS deben crear socio"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act
        response = test_client.post("/api/auth/register", json={
            "email": f"{prefijo}@grupoconexion.uy",
            "nombre": f"Socio {prefijo}",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:401: AssertionError
_____________ TestSociosAutorizados.test_prefijo_case_insensitive ______________

self = <tests.test_auth_endpoints.TestSociosAutorizados object at 0x7fafb999b8f0>
client = (<starlette.testclient.TestClient object at 0x7fafb999ab70>, <Mock id='140392709862224'>)

    def test_prefijo_case_insensitive(self, client):
        """El prefijo debe ser case-insensitive"""
        # Arrange
        test_client, mock_db = client
        mock_db.query.return_value.filter.return_value.first.return_value = None
    
        # Act - Usar maysculas
        response = test_client.post("/api/auth/register", json={
            "email": "ABORIO@grupoconexion.uy",
            "nombre": "Aborio Mayusculas",
            "password": "password123"
        })
    
        # Assert
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_auth_endpoints.py:419: AssertionError
_______________ TestInicializacion.test_init_con_api_key_valida ________________

self = <tests.test_claude_sql_generator.TestInicializacion object at 0x7fb0601bd220>
mock_anthropic = <MagicMock name='Anthropic' id='140392707272880'>

    @patch('anthropic.Anthropic')
    def test_init_con_api_key_valida(self, mock_anthropic):
        """Inicializacin exitosa con API key vlida"""
        # Arrange
        with patch.dict(os.environ, {'ANTHROPIC_API_KEY': 'sk-ant-test-key'}):
            # Act
            generator = ClaudeSQLGenerator()
    
            # Assert
>           assert generator.client is not None
                   ^^^^^^^^^^^^^^^^
E           AttributeError: 'ClaudeSQLGenerator' object has no attribute 'client'

tests/test_claude_sql_generator.py:62: AttributeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:07 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
___________________ TestInicializacion.test_init_sin_api_key ___________________

self = <tests.test_claude_sql_generator.TestInicializacion object at 0x7fb0601bcec0>

    def test_init_sin_api_key(self):
        """Sin API key debe lanzar ValueError"""
        # Arrange
        with patch.dict(os.environ, {}, clear=True):
            # Act & Assert
>           with pytest.raises(ValueError) as exc_info:
E           Failed: DID NOT RAISE <class 'ValueError'>

tests/test_claude_sql_generator.py:70: Failed
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:07 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
____________ TestInicializacion.test_business_context_con_8_reglas _____________

self = <tests.test_claude_sql_generator.TestInicializacion object at 0x7fb0601bf320>
mock_anthropic = <MagicMock name='Anthropic' id='140392704897440'>

    @patch('anthropic.Anthropic')
    def test_business_context_con_8_reglas(self, mock_anthropic):
        """BUSINESS_CONTEXT debe tener las 8 reglas crticas"""
        # Arrange
        with patch.dict(os.environ, {'ANTHROPIC_API_KEY': 'test-key'}):
            generator = ClaudeSQLGenerator()
    
            # Assert
            assert generator.BUSINESS_CONTEXT is not None
            assert len(generator.BUSINESS_CONTEXT) > 1000
    
            # Verificar las 8 reglas
            reglas = [
                '1. PORCENTAJES DE MONEDA',
                '2. RANKINGS Y TOP N',
                '3. DISTRIBUCIONES POR SOCIO',
                '4. AFIRMACIONES DE UNICIDAD',
                '5. UNION ALL CON COLUMNAS ENUM',
                '6. PROYECCIONES TEMPORALES',
                '7. FILTROS TEMPORALES POR DEFECTO',
                '8. CONVERSIONES DE MONEDA EN AGREGACIONES'
            ]
    
            for regla in reglas:
>               assert regla in generator.BUSINESS_CONTEXT, f"Falta regla: {regla}"
E               AssertionError: Falta regla: 7. FILTROS TEMPORALES POR DEFECTO
E               assert '7. FILTROS TEMPORALES POR DEFECTO' in '\nCONTEXTO DEL NEGOCIO - CONEXIN CONSULTORA:\n Consultora uruguaya con 5 socios: Agustina, Viviana, Gonzalo, Pancho...enar ANTES del UNION\n\nIMPORTANTE: Si una query viola alguna de estas reglas, usar approach alternativo ms seguro.\n'
E                +  where '\nCONTEXTO DEL NEGOCIO - CONEXIN CONSULTORA:\n Consultora uruguaya con 5 socios: Agustina, Viviana, Gonzalo, Pancho...enar ANTES del UNION\n\nIMPORTANTE: Si una query viola alguna de estas reglas, usar approach alternativo ms seguro.\n' = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb95e3140>.BUSINESS_CONTEXT

tests/test_claude_sql_generator.py:113: AssertionError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:07 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
__________________ TestGenerarSQL.test_generar_sql_error_api ___________________

self = <tests.test_claude_sql_generator.TestGenerarSQL object at 0x7fb0601bf950>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb94ca300>
mock_anthropic_client = <Mock id='140392704939152'>

    def test_generar_sql_error_api(self, generator_instance, mock_anthropic_client):
        """Error de API debe capturarse y retornar ERROR:"""
        # Arrange
        mock_anthropic_client.messages.create.side_effect = Exception("API Connection Error")
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb8456730>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb8456730> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:165: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:07 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (Exception): API Connection Error
2025-12-18 11:33:07 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:10 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:10 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:12 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
E0000 00:00:1766068390.546987    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (Exception): API Connection Error
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
___________________ TestGenerarSQL.test_generar_sql_timeout ____________________

self = <tests.test_claude_sql_generator.TestGenerarSQL object at 0x7fb0601bfb30>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb0530050>
mock_anthropic_client = <Mock id='140392581163840'>

    def test_generar_sql_timeout(self, generator_instance, mock_anthropic_client):
        """Timeout de API debe manejarse"""
        # Arrange
        mock_anthropic_client.messages.create.side_effect = Exception("Timeout")
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb0594d70>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb0594d70> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:178: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:12 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (Exception): Timeout
2025-12-18 11:33:12 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:14 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:14 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:15 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
E0000 00:00:1766068394.171029    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (Exception): Timeout
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
__________________ TestGenerarSQL.test_generar_sql_rate_limit __________________

self = <tests.test_claude_sql_generator.TestGenerarSQL object at 0x7fb0601bfd10>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb0533f50>
mock_anthropic_client = <Mock id='140392554242288'>

    def test_generar_sql_rate_limit(self, generator_instance, mock_anthropic_client):
        """Rate limit de API debe manejarse"""
        # Arrange
        mock_anthropic_client.messages.create.side_effect = Exception("Rate limit exceeded")
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb1efedf0>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb1efedf0> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:190: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:15 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (Exception): Rate limit exceeded
2025-12-18 11:33:15 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:17 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:17 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
E0000 00:00:1766068397.825460    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (Exception): Rate limit exceeded
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_____________ TestGenerarSQL.test_generar_sql_parametros_correctos _____________

self = <tests.test_claude_sql_generator.TestGenerarSQL object at 0x7fb0601bfef0>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb0550c80>
mock_anthropic_client = <Mock id='140392554374896'>

    def test_generar_sql_parametros_correctos(self, generator_instance, mock_anthropic_client):
        """Debe llamar a Anthropic con parmetros correctos"""
        # Arrange
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
        # Verificar que se llam con parmetros correctos
        mock_anthropic_client.messages.create.assert_called_once()
        call_args = mock_anthropic_client.messages.create.call_args
    
        assert call_args.kwargs['model'] == 'claude-sonnet-4-5-20250929'
>       assert call_args.kwargs['max_tokens'] == 1500
E       assert 4000 == 1500

tests/test_claude_sql_generator.py:207: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude respondi (63 chars)
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:178 AIOrchestrator: Claude respondi (63 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_________________ TestContextoYPrompt.test_prompt_incluye_ddl __________________

self = <tests.test_claude_sql_generator.TestContextoYPrompt object at 0x7fafb97d4170>
mock_anthropic = <MagicMock name='Anthropic' id='140392554367264'>

    @patch('anthropic.Anthropic')
    def test_prompt_incluye_ddl(self, mock_anthropic):
        """Prompt debe incluir DDL_CONTEXT"""
        # Arrange
        with patch.dict(os.environ, {'ANTHROPIC_API_KEY': 'test-key'}):
            generator = ClaudeSQLGenerator()
            mock_client = Mock()
            generator.client = mock_client
    
            # Mock response
            mock_content = Mock()
            mock_content.text = "SELECT 1"
            mock_response = Mock()
            mock_response.content = [mock_content]
            mock_client.messages.create.return_value = mock_response
    
            pregunta = "Test"
    
            # Act
            sql = generator.generar_sql(pregunta)
    
            # Assert
            call_args = mock_client.messages.create.call_args
>           prompt = call_args.kwargs['messages'][0]['content']
                     ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'kwargs'

tests/test_claude_sql_generator.py:241: AttributeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude respondi (0 chars)
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:178 AIOrchestrator: Claude respondi (0 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
___________ TestContextoYPrompt.test_prompt_incluye_business_context ___________

self = <tests.test_claude_sql_generator.TestContextoYPrompt object at 0x7fafb97d4320>
mock_anthropic = <MagicMock name='Anthropic' id='140392554198656'>

    @patch('anthropic.Anthropic')
    def test_prompt_incluye_business_context(self, mock_anthropic):
        """Prompt debe incluir BUSINESS_CONTEXT con reglas"""
        # Arrange
        with patch.dict(os.environ, {'ANTHROPIC_API_KEY': 'test-key'}):
            generator = ClaudeSQLGenerator()
            mock_client = Mock()
            generator.client = mock_client
    
            mock_content = Mock()
            mock_content.text = "SELECT 1"
            mock_response = Mock()
            mock_response.content = [mock_content]
            mock_client.messages.create.return_value = mock_response
    
            pregunta = "Test"
    
            # Act
            sql = generator.generar_sql(pregunta)
    
            # Assert
            call_args = mock_client.messages.create.call_args
>           prompt = call_args.kwargs['messages'][0]['content']
                     ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'kwargs'

tests/test_claude_sql_generator.py:268: AttributeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude respondi (0 chars)
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:178 AIOrchestrator: Claude respondi (0 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
___________ TestContextoYPrompt.test_prompt_incluye_pregunta_usuario ___________

self = <tests.test_claude_sql_generator.TestContextoYPrompt object at 0x7fafb97d44d0>
mock_anthropic = <MagicMock name='Anthropic' id='140392554670960'>

    @patch('anthropic.Anthropic')
    def test_prompt_incluye_pregunta_usuario(self, mock_anthropic):
        """Prompt debe incluir la pregunta del usuario"""
        # Arrange
        with patch.dict(os.environ, {'ANTHROPIC_API_KEY': 'test-key'}):
            generator = ClaudeSQLGenerator()
            mock_client = Mock()
            generator.client = mock_client
    
            mock_content = Mock()
            mock_content.text = "SELECT 1"
            mock_response = Mock()
            mock_response.content = [mock_content]
            mock_client.messages.create.return_value = mock_response
    
            pregunta = "Cunto facturamos en octubre?"
    
            # Act
            sql = generator.generar_sql(pregunta)
    
            # Assert
            call_args = mock_client.messages.create.call_args
>           prompt = call_args.kwargs['messages'][0]['content']
                     ^^^^^^^^^^^^^^^^
E           AttributeError: 'NoneType' object has no attribute 'kwargs'

tests/test_claude_sql_generator.py:296: AttributeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude respondi (0 chars)
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:178 AIOrchestrator: Claude respondi (0 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_________________ TestManejoErrores.test_api_connection_error __________________

self = <tests.test_claude_sql_generator.TestManejoErrores object at 0x7fafb97d45c0>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb05acc80>
mock_anthropic_client = <Mock id='140392554498384'>

    def test_api_connection_error(self, generator_instance, mock_anthropic_client):
        """Connection error debe capturarse"""
        # Arrange
        mock_anthropic_client.messages.create.side_effect = Exception("Connection failed")
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb051e7f0>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb051e7f0> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:438: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:19 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (Exception): Connection failed
2025-12-18 11:33:19 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:21 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:21 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:23 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
E0000 00:00:1766068401.909413    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (Exception): Connection failed
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_________________ TestManejoErrores.test_authentication_error __________________

self = <tests.test_claude_sql_generator.TestManejoErrores object at 0x7fafb97d49e0>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb05ad820>
mock_anthropic_client = <Mock id='140392554504960'>

    def test_authentication_error(self, generator_instance, mock_anthropic_client):
        """Authentication error debe capturarse"""
        # Arrange
        mock_anthropic_client.messages.create.side_effect = Exception("Invalid API key")
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb05cc5b0>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb05cc5b0> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:451: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:23 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (Exception): Invalid API key
2025-12-18 11:33:23 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:25 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:25 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:26 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:26 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
E0000 00:00:1766068405.346983    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (Exception): Invalid API key
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_________________ TestManejoErrores.test_respuesta_sin_content _________________

self = <tests.test_claude_sql_generator.TestManejoErrores object at 0x7fafb97d4fb0>
generator_instance = <app.services.claude_sql_generator.ClaudeSQLGenerator object at 0x7fafb0525910>
mock_anthropic_client = <Mock id='140392554505968'>

    def test_respuesta_sin_content(self, generator_instance, mock_anthropic_client):
        """Respuesta sin campo content debe manejarse"""
        # Arrange
        mock_response = Mock()
        mock_response.content = []  # Lista vaca
        mock_anthropic_client.messages.create.return_value = mock_response
    
        pregunta = "Test"
    
        # Act
        sql = generator_instance.generar_sql(pregunta)
    
        # Assert
        # El cdigo captura el IndexError y retorna "ERROR:..."
>       assert sql.startswith("ERROR:")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fafb05e5030>('ERROR:')
E        +    where <built-in method startswith of str object at 0x7fafb05e5030> = 'SELECT 1;'.startswith

tests/test_claude_sql_generator.py:484: AssertionError
---------------------------- Captured stdout setup -----------------------------
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:30 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
------------------------------ Captured log setup ------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: Claude fall (IndexError): list index out of range
2025-12-18 11:33:30 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
2025-12-18 11:33:32 - app.services.ai.ai_orchestrator - WARNING - AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
2025-12-18 11:33:32 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
2025-12-18 11:33:33 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini respondi (10 chars)
2025-12-18 11:33:33 - app.services.claude_sql_generator - INFO - SQL generado con 0 mensajes de contexto
----------------------------- Captured stderr call -----------------------------
E0000 00:00:1766068412.495964    1625 alts_credentials.cc:93] ALTS creds ignored. Not running on GCP and untrusted ALTS is not enabled.
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:162 AIOrchestrator: Intentando Claude (claude-sonnet-4-5-20250929)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:183 AIOrchestrator: Claude fall (IndexError): list index out of range
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:196 AIOrchestrator: Intentando OpenAI (gpt-3.5-turbo)
WARNING  app.services.ai.ai_orchestrator:ai_orchestrator.py:218 AIOrchestrator: OpenAI fall (RateLimitError): Error code: 429 - {'error': {'message': 'You exceeded your current quota, please check your plan and billing details. For more information on this error, read the docs: https://platform.openai.com/docs/guides/error-codes/api-errors.', 'type': 'insufficient_quota', 'param': None, 'code': 'insufficient_quota'}}
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:231 AIOrchestrator: Intentando Gemini (gemini-2.0-flash)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:252 AIOrchestrator: Gemini respondi (10 chars)
INFO     app.services.claude_sql_generator:claude_sql_generator.py:416 SQL generado con 0 mensajes de contexto
_______ TestChainOfThoughtIntegration.test_obtener_metadatos_temporales ________

self = <sqlalchemy.engine.base.Connection object at 0x7fafbca0c380>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050f980>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0573320>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0570260>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050f980>
cursor = <cursor object at 0x7fafb05fa110; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0573320>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtIntegration object at 0x7fafb98428a0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb050e3c0>

    def test_obtener_metadatos_temporales(self, db_session):
        """Chain-of-Thought debe obtener metadatos reales de BD"""
        # Arrange
        sql_metadatos = ChainOfThoughtSQL.generar_sql_metadatos()
    
        # Act
>       result = db_session.execute(text(sql_metadatos))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050f980>
cursor = <cursor object at 0x7fafb05fa110; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0573320>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^
E       
E       [SQL: 
E       SELECT 
E           CURRENT_DATE as fecha_actual,
E           EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
E           EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
E           (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
E           12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
E           (SELECT MAX(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
E           (SELECT MIN(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_________ TestChainOfThoughtIntegration.test_generar_con_cot_completo __________

self = <tests.test_integration.TestChainOfThoughtIntegration object at 0x7fafb9842c00>
mock_generar = <MagicMock name='generar_sql_con_contexto' id='140392705957264'>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0598b30>

    @patch('app.services.chain_of_thought_sql.ChainOfThoughtSQL.generar_sql_con_contexto')
    def test_generar_con_cot_completo(self, mock_generar, db_session):
        """generar_con_chain_of_thought ejecuta flujo completo"""
        # Arrange
        from app.services.claude_sql_generator import ClaudeSQLGenerator
    
        mock_generar.return_value = "SELECT SUM(monto_uyu) FROM operaciones"
        pregunta = "Proyeccin fin de ao"
    
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            with patch('anthropic.Anthropic'):
                claude_gen = ClaudeSQLGenerator()
    
                # Act
                resultado = generar_con_chain_of_thought(pregunta, db_session, claude_gen)
    
                # Assert
>               assert resultado['exito'] is True
E               assert False is True

tests/test_integration.py:127: AssertionError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:39 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:39 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:39 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:39 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:39 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
2025-12-18 11:33:39 - app.services.chain_of_thought_sql - INFO - Chain-of-Thought detectada pregunta temporal compleja
2025-12-18 11:33:39 - app.services.chain_of_thought_sql - INFO - Chain-of-Thought obteniendo metadatos temporales
2025-12-18 11:33:39 - app.services.chain_of_thought_sql - ERROR - Error en Chain-of-Thought: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^

[SQL: 
SELECT 
    CURRENT_DATE as fecha_actual,
    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
    EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
    (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
    12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
    (SELECT MAX(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
    (SELECT MIN(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
]
(Background on this error at: https://sqlalche.me/e/20/f405)
Traceback (most recent call last):
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1967, in _exec_single_context
    self.dialect.do_execute(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py", line 941, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/brunogandolfo/cfo-inteligente/backend/app/services/chain_of_thought_sql.py", line 211, in generar_con_chain_of_thought
    result = db_session.execute(text(sql_metadatos))
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py", line 2362, in execute
    return self._execute_internal(
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py", line 2256, in _execute_internal
    result = conn.execute(
             ^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1418, in execute
    return meth(
           ^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py", line 515, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1640, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1846, in _execute_context
    return self._exec_single_context(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1986, in _exec_single_context
    self._handle_dbapi_exception(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 2355, in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1967, in _exec_single_context
    self.dialect.do_execute(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py", line 941, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^

[SQL: 
SELECT 
    CURRENT_DATE as fecha_actual,
    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
    EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
    (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
    12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
    (SELECT MAX(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
    (SELECT MIN(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
]
(Background on this error at: https://sqlalche.me/e/20/f405)
------------------------------ Captured log call -------------------------------
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
INFO     app.services.chain_of_thought_sql:chain_of_thought_sql.py:203 Chain-of-Thought detectada pregunta temporal compleja
INFO     app.services.chain_of_thought_sql:chain_of_thought_sql.py:208 Chain-of-Thought obteniendo metadatos temporales
ERROR    app.services.chain_of_thought_sql:chain_of_thought_sql.py:243 Error en Chain-of-Thought: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^

[SQL: 
SELECT 
    CURRENT_DATE as fecha_actual,
    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
    EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
    (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
    12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
    (SELECT MAX(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
    (SELECT MIN(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
]
(Background on this error at: https://sqlalche.me/e/20/f405)
Traceback (most recent call last):
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1967, in _exec_single_context
    self.dialect.do_execute(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py", line 941, in do_execute
    cursor.execute(statement, parameters)
psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^


The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/brunogandolfo/cfo-inteligente/backend/app/services/chain_of_thought_sql.py", line 211, in generar_con_chain_of_thought
    result = db_session.execute(text(sql_metadatos))
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py", line 2362, in execute
    return self._execute_internal(
           ^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py", line 2256, in _execute_internal
    result = conn.execute(
             ^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1418, in execute
    return meth(
           ^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py", line 515, in _execute_on_connection
    return connection._execute_clauseelement(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1640, in _execute_clauseelement
    ret = self._execute_context(
          ^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1846, in _execute_context
    return self._exec_single_context(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1986, in _exec_single_context
    self._handle_dbapi_exception(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 2355, in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py", line 1967, in _exec_single_context
    self.dialect.do_execute(
  File "/home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py", line 941, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
LINE 7:      FROM operaciones
                  ^

[SQL: 
SELECT 
    CURRENT_DATE as fecha_actual,
    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
    EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
    (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
    12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
    (SELECT MAX(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
    (SELECT MIN(DATE_TRUNC('month', fecha))
     FROM operaciones
     WHERE deleted_at IS NULL
       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
]
(Background on this error at: https://sqlalche.me/e/20/f405)
_______________ TestEndpointCFOAsk.test_endpoint_pregunta_simple _______________

args = (<tests.test_integration.TestEndpointCFOAsk object at 0x7fafb9842e10>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb95e1070>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb981bcb0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
______________ TestEndpointCFOAsk.test_endpoint_pregunta_compleja ______________

args = (<tests.test_integration.TestEndpointCFOAsk object at 0x7fafb9842fc0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb1e53650>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb981adb0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
________________ TestEndpointCFOAsk.test_endpoint_sql_invalido _________________

self = <tests.test_integration.TestEndpointCFOAsk object at 0x7fafb9843170>
mock_claude_gen = <MagicMock name='generar_sql' id='140392581166240'>
client_api = <starlette.testclient.TestClient object at 0x7fafb1edfaa0>

    @patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql')
    def test_endpoint_sql_invalido(self, mock_claude_gen, client_api):
        """Endpoint con SQL invlido debe retornar error"""
        # Arrange
        mock_claude_gen.side_effect = Exception("Claude error")
    
        # Mockear Vanna tambin para que falle
        with patch('app.services.sql_router.vn.generate_sql', return_value=None):
            # Act
            response = client_api.post("/api/cfo/ask", json={
                "pregunta": "Query imposible de generar"
            })
    
            # Assert
>           assert response.status_code == 200  # No crashea
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           assert 401 == 200
E            +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_integration.py:217: AssertionError
______________ TestEndpointCFOAsk.test_endpoint_formato_response _______________

self = <tests.test_integration.TestEndpointCFOAsk object at 0x7fafb9843320>
client_api = <starlette.testclient.TestClient object at 0x7fafb0551190>

    def test_endpoint_formato_response(self, client_api):
        """Response debe tener formato correcto siempre"""
        # Arrange
        with patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql') as mock_gen:
            mock_gen.return_value = "SELECT 1 as numero"
    
>           with patch('app.api.cfo_ai.client') as mock_client:

tests/test_integration.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb0552ff0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
______________ TestSQLRouterIntegration.test_sql_ejecutable_en_bd ______________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb05331a0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553c20>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05302c0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0531340>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553c20>
cursor = <cursor object at 0x7fafb04b46d0; closed: -1>
statement = "SELECT COUNT(*) AS total FROM operaciones WHERE deleted_at IS NULL AND DATE_TRUNC('month',fecha)=DATE_TRUNC('month',CURRENT_DATE)"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05302c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: SELECT COUNT(*) AS total FROM operaciones WHERE deleted_at I...
E                                             ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestSQLRouterIntegration object at 0x7fafb9843530>
mock_claude_gen = <MagicMock name='generar_sql' id='140392554377776'>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0552960>

    @patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql')
    def test_sql_ejecutable_en_bd(self, mock_claude_gen, db_session):
        """SQL generado debe ser ejecutable en BD real"""
        # Arrange
        sql = "SELECT COUNT(*) as total FROM operaciones WHERE deleted_at IS NULL"
        mock_claude_gen.return_value = sql
    
        # Act - Generar SQL
        resultado = generar_sql_inteligente("Cuntas operaciones hay?")
    
        # Assert - SQL se gener
        assert resultado['exito'] is True
        assert resultado['sql'] is not None
    
        # Ejecutar SQL en BD real
>       result = db_session.execute(text(resultado['sql']))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553c20>
cursor = <cursor object at 0x7fafb04b46d0; closed: -1>
statement = "SELECT COUNT(*) AS total FROM operaciones WHERE deleted_at IS NULL AND DATE_TRUNC('month',fecha)=DATE_TRUNC('month',CURRENT_DATE)"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05302c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: SELECT COUNT(*) AS total FROM operaciones WHERE deleted_at I...
E                                             ^
E       
E       [SQL: SELECT COUNT(*) AS total FROM operaciones WHERE deleted_at IS NULL AND DATE_TRUNC('month',fecha)=DATE_TRUNC('month',CURRENT_DATE)]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:40 - app.services.sql_router - INFO - Inicializando SQL Router (Claude + Vanna)
2025-12-18 11:33:40 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Claude inicializado
2025-12-18 11:33:40 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: OpenAI inicializado
2025-12-18 11:33:40 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Gemini inicializado
2025-12-18 11:33:40 - app.services.ai.ai_orchestrator - INFO - AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
2025-12-18 11:33:40 - app.services.claude_sql_generator - INFO - ClaudeSQLGenerator inicializado con AIOrchestrator
2025-12-18 11:33:40 - app.services.sql_router - INFO - SQL Router procesando pregunta: 'Cuntas operaciones hay?'
2025-12-18 11:33:40 - app.services.sql_router - INFO - SQL Router usando QueryFallback para: 'Cuntas operaciones hay?'
------------------------------ Captured log call -------------------------------
INFO     app.services.sql_router:sql_router.py:567 Inicializando SQL Router (Claude + Vanna)
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:67 AIOrchestrator: Claude inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:78 AIOrchestrator: OpenAI inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:88 AIOrchestrator: Gemini inicializado
INFO     app.services.ai.ai_orchestrator:ai_orchestrator.py:102 AIOrchestrator: Proveedores disponibles: Claude, OpenAI, Gemini
INFO     app.services.claude_sql_generator:claude_sql_generator.py:353 ClaudeSQLGenerator inicializado con AIOrchestrator
INFO     app.services.sql_router:sql_router.py:418 SQL Router procesando pregunta: 'Cuntas operaciones hay?'
INFO     app.services.sql_router:sql_router.py:428 SQL Router usando QueryFallback para: 'Cuntas operaciones hay?'
__________ TestSQLRouterIntegration.test_sql_rentabilidad_ejecutable ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0553d70>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553770>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0552450>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0551160>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553770>
cursor = <cursor object at 0x7fafb05fa6b0; closed: -1>
statement = "SELECT ((SUM(CASE WHEN o.tipo_operacion='INGRESO' THEN o.monto_uyu ELSE 0 END)-SUM(CASE WHEN o.tipo_operacion='GASTO'...bilidad FROM operaciones o WHERE o.deleted_at IS NULL AND DATE_TRUNC('month',o.fecha)=DATE_TRUNC('month',CURRENT_DATE)"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0552450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: ...onto_uyu ELSE 0 END),0))*100 AS rentabilidad FROM operacione...
E                                                                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestSQLRouterIntegration object at 0x7fafb98436e0>
mock_claude_gen = <MagicMock name='generar_sql' id='140392554379072'>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0550ef0>

    @patch('app.services.claude_sql_generator.ClaudeSQLGenerator.generar_sql')
    def test_sql_rentabilidad_ejecutable(self, mock_claude_gen, db_session):
        """SQL de rentabilidad debe ejecutarse y retornar valor vlido"""
        # Arrange
        sql_rentabilidad = """
        SELECT
            ROUND(
                ((SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) -
                  SUM(CASE WHEN tipo_operacion='GASTO' THEN monto_uyu ELSE 0 END)) /
                 NULLIF(SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END), 0)) * 100,
                2
            ) AS rentabilidad
        FROM operaciones
        WHERE deleted_at IS NULL
        AND DATE_TRUNC('month', fecha) = DATE_TRUNC('month', CURRENT_DATE)
        """
        mock_claude_gen.return_value = sql_rentabilidad
    
        # Act
        resultado = generar_sql_inteligente("Cul es la rentabilidad?")
    
        # Assert
        assert resultado['exito'] is True
    
        # Ejecutar en BD
>       result = db_session.execute(text(resultado['sql']))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553770>
cursor = <cursor object at 0x7fafb05fa6b0; closed: -1>
statement = "SELECT ((SUM(CASE WHEN o.tipo_operacion='INGRESO' THEN o.monto_uyu ELSE 0 END)-SUM(CASE WHEN o.tipo_operacion='GASTO'...bilidad FROM operaciones o WHERE o.deleted_at IS NULL AND DATE_TRUNC('month',o.fecha)=DATE_TRUNC('month',CURRENT_DATE)"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0552450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: ...onto_uyu ELSE 0 END),0))*100 AS rentabilidad FROM operacione...
E                                                                    ^
E       
E       [SQL: SELECT ((SUM(CASE WHEN o.tipo_operacion='INGRESO' THEN o.monto_uyu ELSE 0 END)-SUM(CASE WHEN o.tipo_operacion='GASTO' THEN o.monto_uyu ELSE 0 END))/NULLIF(SUM(CASE WHEN o.tipo_operacion='INGRESO' THEN o.monto_uyu ELSE 0 END),0))*100 AS rentabilidad FROM operaciones o WHERE o.deleted_at IS NULL AND DATE_TRUNC('month',o.fecha)=DATE_TRUNC('month',CURRENT_DATE)]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:40 - app.services.sql_router - INFO - SQL Router procesando pregunta: 'Cul es la rentabilidad?'
2025-12-18 11:33:40 - app.services.sql_router - INFO - SQL Router usando QueryFallback para: 'Cul es la rentabilidad?'
------------------------------ Captured log call -------------------------------
INFO     app.services.sql_router:sql_router.py:418 SQL Router procesando pregunta: 'Cul es la rentabilidad?'
INFO     app.services.sql_router:sql_router.py:428 SQL Router usando QueryFallback para: 'Cul es la rentabilidad?'
__________ TestValidadorConDatosReales.test_validar_rentabilidad_real __________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb1edf050>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edeae0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edd880>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb1edd4c0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edeae0>
cursor = <cursor object at 0x7fafb04b5d50; closed: -1>
statement = "\n        SELECT \n            ROUND(\n                ((SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0...\n        WHERE deleted_at IS NULL\n        AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edd880>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 9:         FROM operaciones
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestValidadorConDatosReales object at 0x7fafb98434d0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb1edf110>

    def test_validar_rentabilidad_real(self, db_session):
        """Validar rentabilidad con datos reales de BD"""
        # Arrange
        sql = """
        SELECT
            ROUND(
                ((SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) -
                  SUM(CASE WHEN tipo_operacion='GASTO' THEN monto_uyu ELSE 0 END)) /
                 NULLIF(SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END), 0)) * 100,
                2
            ) AS rentabilidad
        FROM operaciones
        WHERE deleted_at IS NULL
        AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)
        """
    
        # Act - Ejecutar SQL
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edeae0>
cursor = <cursor object at 0x7fafb04b5d50; closed: -1>
statement = "\n        SELECT \n            ROUND(\n                ((SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0...\n        WHERE deleted_at IS NULL\n        AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edd880>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 9:         FROM operaciones
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   ROUND(
E                       ((SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) -
E                         SUM(CASE WHEN tipo_operacion='GASTO' THEN monto_uyu ELSE 0 END)) /
E                        NULLIF(SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END), 0)) * 100,
E                       2
E                   ) AS rentabilidad
E               FROM operaciones
E               WHERE deleted_at IS NULL
E               AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
________ TestValidadorConDatosReales.test_validar_distribuciones_reales ________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb94def00>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94dd460>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94df260>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb1f640b0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94dd460>
cursor = <cursor object at 0x7fafb1ee4400; closed: -1>
statement = "\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\...L\n            AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        GROUP BY s.nombre\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94df260>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestValidadorConDatosReales object at 0x7fafb9842f00>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb94dedb0>

    def test_validar_distribuciones_reales(self, db_session):
        """Validar distribuciones con datos reales"""
        # Arrange
        sql = """
        SELECT
            s.nombre,
            COALESCE(SUM(dd.monto_uyu), 0) as total
        FROM socios s
        LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
        LEFT JOIN operaciones o ON o.id = dd.operacion_id
            AND o.deleted_at IS NULL
            AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)
        GROUP BY s.nombre
        """
    
        # Act
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94dd460>
cursor = <cursor object at 0x7fafb1ee4400; closed: -1>
statement = "\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\...L\n            AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        GROUP BY s.nombre\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94df260>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   s.nombre,
E                   COALESCE(SUM(dd.monto_uyu), 0) as total
E               FROM socios s
E               LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
E               LEFT JOIN operaciones o ON o.id = dd.operacion_id 
E                   AND o.deleted_at IS NULL
E                   AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)
E               GROUP BY s.nombre
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
______ TestFlujoCompletoEndToEnd.test_flujo_completo_pregunta_facturacion ______

args = (<tests.test_integration.TestFlujoCompletoEndToEnd object at 0x7fafb98427e0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb9842a80>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9840230>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_________ TestFlujoCompletoEndToEnd.test_flujo_con_validacion_pre_sql __________

args = (<tests.test_integration.TestFlujoCompletoEndToEnd object at 0x7fafb9843a10>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb056b1d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9841970>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
__________ TestFlujoCompletoEndToEnd.test_flujo_con_chain_of_thought ___________

args = (<tests.test_integration.TestFlujoCompletoEndToEnd object at 0x7fafb9843bf0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb0552300>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9841af0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_______________ TestQueriesReales.test_query_conteo_operaciones ________________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0568a10>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0568950>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0568770>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb05686b0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0568950>
cursor = <cursor object at 0x7fafb1ee5f30; closed: -1>
statement = 'SELECT COUNT(*) as total FROM operaciones WHERE deleted_at IS NULL'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0568770>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: SELECT COUNT(*) as total FROM operaciones WHERE deleted_at I...
E                                             ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestQueriesReales object at 0x7fafb9843e30>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0568980>

    def test_query_conteo_operaciones(self, db_session):
        """Query de conteo debe retornar nmero correcto"""
        # Act
        sql = "SELECT COUNT(*) as total FROM operaciones WHERE deleted_at IS NULL"
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0568950>
cursor = <cursor object at 0x7fafb1ee5f30; closed: -1>
statement = 'SELECT COUNT(*) as total FROM operaciones WHERE deleted_at IS NULL'
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0568770>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: SELECT COUNT(*) as total FROM operaciones WHERE deleted_at I...
E                                             ^
E       
E       [SQL: SELECT COUNT(*) as total FROM operaciones WHERE deleted_at IS NULL]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________________ TestQueriesReales.test_query_sum_ingresos ___________________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9842a80>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1e21d60>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553b90>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb05513d0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1e21d60>
cursor = <cursor object at 0x7fafb05fb3d0; closed: -1>
statement = "\n        SELECT SUM(monto_uyu) as total_ingresos\n        FROM operaciones\n        WHERE tipo_operacion = 'INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553b90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 3:         FROM operaciones
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestQueriesReales object at 0x7fafb985c050>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb97d4080>

    def test_query_sum_ingresos(self, db_session):
        """Query de suma de ingresos debe retornar valor razonable"""
        # Act
        sql = """
        SELECT SUM(monto_uyu) as total_ingresos
        FROM operaciones
        WHERE tipo_operacion = 'INGRESO'
        AND deleted_at IS NULL
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1e21d60>
cursor = <cursor object at 0x7fafb05fb3d0; closed: -1>
statement = "\n        SELECT SUM(monto_uyu) as total_ingresos\n        FROM operaciones\n        WHERE tipo_operacion = 'INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0553b90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 3:         FROM operaciones
E                            ^
E       
E       [SQL: 
E               SELECT SUM(monto_uyu) as total_ingresos
E               FROM operaciones
E               WHERE tipo_operacion = 'INGRESO'
E               AND deleted_at IS NULL
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
____________ TestQueriesReales.test_query_distribuciones_por_socio _____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb1edd0a0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edddf0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edf860>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb1edf560>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edddf0>
cursor = <cursor object at 0x7fafb040c9a0; closed: -1>
statement = '\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\... dd.operacion_id\n            AND o.deleted_at IS NULL\n        GROUP BY s.nombre\n        ORDER BY s.nombre\n        '
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edf860>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestQueriesReales object at 0x7fafb985c230>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb1eddcd0>

    def test_query_distribuciones_por_socio(self, db_session):
        """Query de distribuciones debe retornar 5 socios"""
        # Act
        sql = """
        SELECT
            s.nombre,
            COALESCE(SUM(dd.monto_uyu), 0) as total
        FROM socios s
        LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
        LEFT JOIN operaciones o ON o.id = dd.operacion_id
            AND o.deleted_at IS NULL
        GROUP BY s.nombre
        ORDER BY s.nombre
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:537: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb1edddf0>
cursor = <cursor object at 0x7fafb040c9a0; closed: -1>
statement = '\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\... dd.operacion_id\n            AND o.deleted_at IS NULL\n        GROUP BY s.nombre\n        ORDER BY s.nombre\n        '
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1edf860>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   s.nombre,
E                   COALESCE(SUM(dd.monto_uyu), 0) as total
E               FROM socios s
E               LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
E               LEFT JOIN operaciones o ON o.id = dd.operacion_id
E                   AND o.deleted_at IS NULL
E               GROUP BY s.nombre
E               ORDER BY s.nombre
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_______ TestChainOfThoughtAvanzado.test_proyeccion_fin_ao_con_metadatos _______

self = <sqlalchemy.engine.base.Connection object at 0x7fafb05532c0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553fb0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056ba70>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb05699a0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553fb0>
cursor = <cursor object at 0x7fafb1ee6e30; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056ba70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985c860>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0552960>

    def test_proyeccion_fin_ao_con_metadatos(self, db_session):
        """Proyeccin debe usar metadatos reales de BD"""
        # Arrange - Obtener metadatos
        sql_meta = ChainOfThoughtSQL.generar_sql_metadatos()
>       result = db_session.execute(text(sql_meta))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0553fb0>
cursor = <cursor object at 0x7fafb1ee6e30; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056ba70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^
E       
E       [SQL: 
E       SELECT 
E           CURRENT_DATE as fecha_actual,
E           EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
E           EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
E           (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
E           12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
E           (SELECT MAX(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
E           (SELECT MIN(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
____________ TestChainOfThoughtAvanzado.test_comparacion_mes_vs_mes ____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0553cb0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050c950>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050c050>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb050e5d0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050c950>
cursor = <cursor object at 0x7fb0bb1c48b0; closed: -1>
statement = "\n        WITH mensual AS (\n            SELECT \n                DATE_TRUNC('month', fecha) AS mes,\n               ...ORDER BY 1 DESC\n            LIMIT 2\n        )\n        SELECT mes, ingresos FROM mensual ORDER BY mes DESC\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050c050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 6:             FROM operaciones
E                                ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985ca40>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb050f9b0>

    def test_comparacion_mes_vs_mes(self, db_session):
        """Comparacin temporal debe ejecutarse correctamente"""
        # Act
        sql = """
        WITH mensual AS (
            SELECT
                DATE_TRUNC('month', fecha) AS mes,
                SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) as ingresos
            FROM operaciones
            WHERE deleted_at IS NULL
            GROUP BY 1
            ORDER BY 1 DESC
            LIMIT 2
        )
        SELECT mes, ingresos FROM mensual ORDER BY mes DESC
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:628: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050c950>
cursor = <cursor object at 0x7fb0bb1c48b0; closed: -1>
statement = "\n        WITH mensual AS (\n            SELECT \n                DATE_TRUNC('month', fecha) AS mes,\n               ...ORDER BY 1 DESC\n            LIMIT 2\n        )\n        SELECT mes, ingresos FROM mensual ORDER BY mes DESC\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050c050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 6:             FROM operaciones
E                                ^
E       
E       [SQL: 
E               WITH mensual AS (
E                   SELECT 
E                       DATE_TRUNC('month', fecha) AS mes,
E                       SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) as ingresos
E                   FROM operaciones
E                   WHERE deleted_at IS NULL
E                   GROUP BY 1
E                   ORDER BY 1 DESC
E                   LIMIT 2
E               )
E               SELECT mes, ingresos FROM mensual ORDER BY mes DESC
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________ TestChainOfThoughtAvanzado.test_tendencia_ultimos_3_meses ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0568620>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0569ac0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050f380>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb050c110>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0569ac0>
cursor = <cursor object at 0x7fafb05fb4c0; closed: -1>
statement = "\n        SELECT \n            DATE_TRUNC('month', fecha) AS mes,\n            SUM(CASE WHEN tipo_operacion='INGRESO'...AND fecha >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 months'\n        GROUP BY 1\n        ORDER BY 1\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050f380>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985cc20>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb056b470>

    def test_tendencia_ultimos_3_meses(self, db_session):
        """Tendencia de ltimos meses debe retornar datos"""
        # Act
        sql = """
        SELECT
            DATE_TRUNC('month', fecha) AS mes,
            SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) as ingresos
        FROM operaciones
        WHERE deleted_at IS NULL
        AND fecha >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 months'
        GROUP BY 1
        ORDER BY 1
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:652: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0569ac0>
cursor = <cursor object at 0x7fafb05fb4c0; closed: -1>
statement = "\n        SELECT \n            DATE_TRUNC('month', fecha) AS mes,\n            SUM(CASE WHEN tipo_operacion='INGRESO'...AND fecha >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 months'\n        GROUP BY 1\n        ORDER BY 1\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050f380>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   DATE_TRUNC('month', fecha) AS mes,
E                   SUM(CASE WHEN tipo_operacion='INGRESO' THEN monto_uyu ELSE 0 END) as ingresos
E               FROM operaciones
E               WHERE deleted_at IS NULL
E               AND fecha >= DATE_TRUNC('month', CURRENT_DATE) - INTERVAL '2 months'
E               GROUP BY 1
E               ORDER BY 1
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________ TestChainOfThoughtAvanzado.test_conversion_moneda_multiple __________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9819400>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb953bb30>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9818b00>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb981a090>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb953bb30>
cursor = <cursor object at 0x7fafb04b6020; closed: -1>
statement = "\n        SELECT \n            SUM(monto_uyu) as total_uyu,\n            SUM(monto_usd) as total_usd\n        FROM operaciones\n        WHERE tipo_operacion='INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9818b00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985ce00>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb050d0d0>

    def test_conversion_moneda_multiple(self, db_session):
        """Query con conversiones debe retornar ambas monedas"""
        # Act
        sql = """
        SELECT
            SUM(monto_uyu) as total_uyu,
            SUM(monto_usd) as total_usd
        FROM operaciones
        WHERE tipo_operacion='INGRESO'
        AND deleted_at IS NULL
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:670: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb953bb30>
cursor = <cursor object at 0x7fafb04b6020; closed: -1>
statement = "\n        SELECT \n            SUM(monto_uyu) as total_uyu,\n            SUM(monto_usd) as total_usd\n        FROM operaciones\n        WHERE tipo_operacion='INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9818b00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   SUM(monto_uyu) as total_uyu,
E                   SUM(monto_usd) as total_usd
E               FROM operaciones
E               WHERE tipo_operacion='INGRESO'
E               AND deleted_at IS NULL
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_______ TestChainOfThoughtAvanzado.test_metadatos_fecha_actual_correcta ________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb057c320>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057ef90>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057f9e0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb057eb70>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057ef90>
cursor = <cursor object at 0x7fafb04b7880; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057f9e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985d190>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb057c590>

    def test_metadatos_fecha_actual_correcta(self, db_session):
        """Fecha actual en metadatos debe coincidir con CURRENT_DATE"""
        # Act
        sql = "SELECT CURRENT_DATE as hoy"
        result = db_session.execute(text(sql))
        fecha_db = result.fetchone()[0]
    
        # Obtener metadatos
        sql_meta = ChainOfThoughtSQL.generar_sql_metadatos()
>       result2 = db_session.execute(text(sql_meta))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057ef90>
cursor = <cursor object at 0x7fafb04b7880; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057f9e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^
E       
E       [SQL: 
E       SELECT 
E           CURRENT_DATE as fecha_actual,
E           EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
E           EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
E           (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
E           12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
E           (SELECT MAX(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
E           (SELECT MIN(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
___________ TestChainOfThoughtAvanzado.test_meses_con_datos_dinamico ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb94deff0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb056ab10>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050e210>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb056a990>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb056ab10>
cursor = <cursor object at 0x7fafb05fac50; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050e210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985d370>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb05684d0>

    def test_meses_con_datos_dinamico(self, db_session):
        """Meses con datos debe calcularse dinmicamente"""
        # Act
        sql_meta = ChainOfThoughtSQL.generar_sql_metadatos()
>       result = db_session.execute(text(sql_meta))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:713: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb056ab10>
cursor = <cursor object at 0x7fafb05fac50; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb050e210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^
E       
E       [SQL: 
E       SELECT 
E           CURRENT_DATE as fecha_actual,
E           EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
E           EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
E           (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
E           12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
E           (SELECT MAX(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
E           (SELECT MIN(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_____________ TestChainOfThoughtAvanzado.test_ultimo_mes_con_datos _____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0569c10>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057fc20>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94f5c70>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb94f4bc0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057fc20>
cursor = <cursor object at 0x7fafb04b7a60; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94f5c70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestChainOfThoughtAvanzado object at 0x7fafb985d550>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb057e990>

    def test_ultimo_mes_con_datos(self, db_session):
        """ltimo mes con datos debe obtenerse correctamente"""
        # Act
        sql_meta = ChainOfThoughtSQL.generar_sql_metadatos()
>       result = db_session.execute(text(sql_meta))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb057fc20>
cursor = <cursor object at 0x7fafb04b7a60; closed: -1>
statement = "\nSELECT \n    CURRENT_DATE as fecha_actual,\n    EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,\n    EXTRACT(MO...ed_at IS NULL\n       AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025\n"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94f5c70>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 7:      FROM operaciones
E                         ^
E       
E       [SQL: 
E       SELECT 
E           CURRENT_DATE as fecha_actual,
E           EXTRACT(YEAR FROM CURRENT_DATE)::int as ao_actual,
E           EXTRACT(MONTH FROM CURRENT_DATE)::int as mes_actual,
E           (SELECT COUNT(DISTINCT DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as meses_con_datos_2025,
E           12 - EXTRACT(MONTH FROM CURRENT_DATE)::int as meses_restantes_2025,
E           (SELECT MAX(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL) as ultimo_mes_con_datos,
E           (SELECT MIN(DATE_TRUNC('month', fecha))
E            FROM operaciones
E            WHERE deleted_at IS NULL
E              AND DATE_TRUNC('year', fecha) = DATE_TRUNC('year', CURRENT_DATE)) as primer_mes_con_datos_2025
E       ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
____________ TestValidadorPostSQLReal.test_porcentaje_usd_uyu_real _____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb050c8c0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050fc80>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056be00>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0568ad0>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050fc80>
cursor = <cursor object at 0x7fafb96085e0; closed: -1>
statement = "\n        SELECT \n            ROUND(COUNT(CASE WHEN moneda_original='USD' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_...as pct_uyu\n        FROM operaciones\n        WHERE tipo_operacion='INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056be00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestValidadorPostSQLReal object at 0x7fafb985d790>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb050ff20>

    def test_porcentaje_usd_uyu_real(self, db_session):
        """Porcentaje USD vs UYU con datos reales"""
        # Act
        sql = """
        SELECT
            ROUND(COUNT(CASE WHEN moneda_original='USD' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_usd,
            ROUND(COUNT(CASE WHEN moneda_original='UYU' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_uyu
        FROM operaciones
        WHERE tipo_operacion='INGRESO'
        AND deleted_at IS NULL
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb050fc80>
cursor = <cursor object at 0x7fafb96085e0; closed: -1>
statement = "\n        SELECT \n            ROUND(COUNT(CASE WHEN moneda_original='USD' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_...as pct_uyu\n        FROM operaciones\n        WHERE tipo_operacion='INGRESO'\n        AND deleted_at IS NULL\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb056be00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 5:         FROM operaciones
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   ROUND(COUNT(CASE WHEN moneda_original='USD' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_usd,
E                   ROUND(COUNT(CASE WHEN moneda_original='UYU' THEN 1 END) * 100.0 / COUNT(*), 2) as pct_uyu
E               FROM operaciones
E               WHERE tipo_operacion='INGRESO'
E               AND deleted_at IS NULL
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________ TestValidadorPostSQLReal.test_distribucion_por_socio_real ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0543260>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0542450>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0542de0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0543860>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0542450>
cursor = <cursor object at 0x7fafb03416c0; closed: -1>
statement = "\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\...('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        GROUP BY s.nombre\n        ORDER BY total DESC\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0542de0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestValidadorPostSQLReal object at 0x7fafb985d970>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0541280>

    def test_distribucion_por_socio_real(self, db_session):
        """Distribuciones reales no deben exceder lmites artificiales"""
        # Act
        sql = """
        SELECT
            s.nombre,
            COALESCE(SUM(dd.monto_uyu), 0) as total
        FROM socios s
        LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
        LEFT JOIN operaciones o ON o.id = dd.operacion_id
            AND o.deleted_at IS NULL
            AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)
        GROUP BY s.nombre
        ORDER BY total DESC
        """
>       result = db_session.execute(text(sql))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:788: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0542450>
cursor = <cursor object at 0x7fafb03416c0; closed: -1>
statement = "\n        SELECT \n            s.nombre,\n            COALESCE(SUM(dd.monto_uyu), 0) as total\n        FROM socios s\...('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)\n        GROUP BY s.nombre\n        ORDER BY total DESC\n        "
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb0542de0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 5:         FROM socios s
E                            ^
E       
E       [SQL: 
E               SELECT 
E                   s.nombre,
E                   COALESCE(SUM(dd.monto_uyu), 0) as total
E               FROM socios s
E               LEFT JOIN distribuciones_detalle dd ON dd.socio_id = s.id
E               LEFT JOIN operaciones o ON o.id = dd.operacion_id
E                   AND o.deleted_at IS NULL
E                   AND DATE_TRUNC('year', o.fecha) = DATE_TRUNC('year', CURRENT_DATE)
E               GROUP BY s.nombre
E               ORDER BY total DESC
E               ]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
________________ TestCasosCriticos.test_caso_retiros_por_socio _________________

args = (<tests.test_integration.TestCasosCriticos object at 0x7fafb985d4c0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb0568b30>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9842000>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_____________ TestCasosCriticos.test_caso_comparacion_ao_anterior _____________

args = (<tests.test_integration.TestCasosCriticos object at 0x7fafb985cef0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb0542660>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb9842120>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
_____________ TestCasosCriticos.test_caso_gonzalo_recibe_correcto ______________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb0570860>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0570230>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05733b0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0570a10>
parameters = [{}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0570230>
cursor = <cursor object at 0x7fafb0341a80; closed: -1>
statement = "SELECT porcentaje_participacion FROM socios WHERE nombre='Gonzalo'"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05733b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "socios" does not exist
E       LINE 1: SELECT porcentaje_participacion FROM socios WHERE nombre='Go...
E                                                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_integration.TestCasosCriticos object at 0x7fafb985c770>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0572c00>

    def test_caso_gonzalo_recibe_correcto(self, db_session):
        """Verificar que Gonzalo recibe lo que corresponde"""
        # Act - Obtener % participacin
        sql_participacion = "SELECT porcentaje_participacion FROM socios WHERE nombre='Gonzalo'"
>       result1 = db_session.execute(text(sql_participacion))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_integration.py:915: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2256: in _execute_internal
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0570230>
cursor = <cursor object at 0x7fafb0341a80; closed: -1>
statement = "SELECT porcentaje_participacion FROM socios WHERE nombre='Gonzalo'"
parameters = {}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05733b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "socios" does not exist
E       LINE 1: SELECT porcentaje_participacion FROM socios WHERE nombre='Go...
E                                                    ^
E       
E       [SQL: SELECT porcentaje_participacion FROM socios WHERE nombre='Gonzalo']
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
________________ TestCasosCriticos.test_caso_estamos_creciendo _________________

args = (<tests.test_integration.TestCasosCriticos object at 0x7fafb985c1a0>,)
keywargs = {'client_api': <starlette.testclient.TestClient object at 0x7fafb05734d0>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x7fafb98422a0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.api.cfo_ai' from '/home/brunogandolfo/cfo-inteligente/backend/app/api/cfo_ai.py'> does not have the attribute 'client'

/usr/lib/python3.12/unittest/mock.py:1431: AttributeError
___________ TestAuthIntegration.test_registro_y_login_flujo_completo ___________

self = <tests.test_integration_real.TestAuthIntegration object at 0x7fafb985fb60>
client = <starlette.testclient.TestClient object at 0x7fafb0524e00>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0524800>

    def test_registro_y_login_flujo_completo(self, client, db_session):
        """Flujo completo: registro  login  obtener token"""
        # 1. Registrar usuario
        registro_response = client.post("/api/auth/register", json={
            "email": "nuevo@grupoconexion.uy",
            "nombre": "Nuevo Usuario",
            "password": "password123"
        })
    
>       assert registro_response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_integration_real.py:153: AssertionError
______________ TestAuthIntegration.test_registro_socio_autorizado ______________

self = <tests.test_integration_real.TestAuthIntegration object at 0x7fafb985fcb0>
client = <starlette.testclient.TestClient object at 0x7fafa4788410>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb94fc230>

    def test_registro_socio_autorizado(self, client, db_session):
        """Email autorizado se registra como socio"""
        response = client.post("/api/auth/register", json={
            "email": "aborio@grupoconexion.uy",
            "nombre": "Aborio Test",
            "password": "password123"
        })
    
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_integration_real.py:211: AssertionError
________________ TestAuthIntegration.test_registro_colaborador _________________

self = <tests.test_integration_real.TestAuthIntegration object at 0x7fafb985cb90>
client = <starlette.testclient.TestClient object at 0x7fafa4788830>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb05729c0>

    def test_registro_colaborador(self, client, db_session):
        """Email no autorizado se registra como colaborador"""
        response = client.post("/api/auth/register", json={
            "email": "colaborador@grupoconexion.uy",
            "nombre": "Colaborador Test",
            "password": "password123"
        })
    
>       assert response.status_code == 201
E       assert 401 == 201
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/test_integration_real.py:228: AssertionError
____________________ test_aggregator_calcula_todas_metricas ____________________

sample_operaciones = [<Mock id='140392554306480'>, <Mock id='140392554305232'>, <Mock id='140392554306048'>, <Mock id='140392554307536'>, <Mock id='140392554314928'>]

    def test_aggregator_calcula_todas_metricas(sample_operaciones):
        """Test: MetricsAggregator calcula todas las mtricas."""
        aggregator = MetricsAggregator(
            operaciones=sample_operaciones,
            fecha_inicio=date(2025, 10, 1),
            fecha_fin=date(2025, 10, 31)
        )
    
>       metricas = aggregator.aggregate_all()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_metrics_aggregator.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/metrics/metrics_aggregator.py:221: in aggregate_all
    series_temporales = self._calculate_series_temporales()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.metrics.metrics_aggregator.MetricsAggregator object at 0x7fafb05432c0>

    def _calculate_series_temporales(self) -> Dict[str, Any]:
        """
        Calcula series temporales mensuales para grficos de lnea.
    
        Agrupa operaciones por mes y calcula:
        - Ingresos mensuales
        - Gastos mensuales
        - Utilidad mensual (ingresos - gastos)
    
        Returns:
            Dict con 4 listas:
            {
                'meses': ['Oct 2025', 'Nov 2025', ...],
                'ingresos_por_mes': [150000, 180000, ...],
                'gastos_por_mes': [50000, 60000, ...],
                'utilidad_por_mes': [100000, 120000, ...]
            }
        """
        from datetime import datetime
        from collections import defaultdict
        from app.models import TipoOperacion
    
        # Agrupar operaciones por mes
        ops_por_mes = defaultdict(lambda: {'ingresos': 0, 'gastos': 0})
    
        for op in self.operaciones:
            mes_key = op.fecha.strftime('%Y-%m')
    
            if op.tipo_operacion == TipoOperacion.INGRESO:
                ops_por_mes[mes_key]['ingresos'] += float(op.monto_uyu)
            elif op.tipo_operacion == TipoOperacion.GASTO:
                ops_por_mes[mes_key]['gastos'] += float(op.monto_uyu)
    
        # Ordenar por fecha
>       meses_ordenados = sorted(ops_por_mes.keys())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'Mock' and 'Mock'

app/services/metrics/metrics_aggregator.py:372: TypeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Iniciando agregacin de mtricas: 5 operaciones
------------------------------ Captured log call -------------------------------
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:126 Iniciando agregacin de mtricas: 5 operaciones
_______________________ test_aggregator_totals_correctos _______________________

sample_operaciones = [<Mock id='140392554092576'>, <Mock id='140392554430688'>, <Mock id='140392554096272'>, <Mock id='140392554315696'>, <Mock id='140392554094928'>]

    def test_aggregator_totals_correctos(sample_operaciones):
        """Test: Totals correctos."""
        aggregator = MetricsAggregator(
            operaciones=sample_operaciones,
            fecha_inicio=date(2025, 10, 1),
            fecha_fin=date(2025, 10, 31)
        )
    
>       metricas = aggregator.aggregate_all()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_metrics_aggregator.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/metrics/metrics_aggregator.py:221: in aggregate_all
    series_temporales = self._calculate_series_temporales()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.metrics.metrics_aggregator.MetricsAggregator object at 0x7fafb0543e00>

    def _calculate_series_temporales(self) -> Dict[str, Any]:
        """
        Calcula series temporales mensuales para grficos de lnea.
    
        Agrupa operaciones por mes y calcula:
        - Ingresos mensuales
        - Gastos mensuales
        - Utilidad mensual (ingresos - gastos)
    
        Returns:
            Dict con 4 listas:
            {
                'meses': ['Oct 2025', 'Nov 2025', ...],
                'ingresos_por_mes': [150000, 180000, ...],
                'gastos_por_mes': [50000, 60000, ...],
                'utilidad_por_mes': [100000, 120000, ...]
            }
        """
        from datetime import datetime
        from collections import defaultdict
        from app.models import TipoOperacion
    
        # Agrupar operaciones por mes
        ops_por_mes = defaultdict(lambda: {'ingresos': 0, 'gastos': 0})
    
        for op in self.operaciones:
            mes_key = op.fecha.strftime('%Y-%m')
    
            if op.tipo_operacion == TipoOperacion.INGRESO:
                ops_por_mes[mes_key]['ingresos'] += float(op.monto_uyu)
            elif op.tipo_operacion == TipoOperacion.GASTO:
                ops_por_mes[mes_key]['gastos'] += float(op.monto_uyu)
    
        # Ordenar por fecha
>       meses_ordenados = sorted(ops_por_mes.keys())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'Mock' and 'Mock'

app/services/metrics/metrics_aggregator.py:372: TypeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Iniciando agregacin de mtricas: 5 operaciones
------------------------------ Captured log call -------------------------------
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:126 Iniciando agregacin de mtricas: 5 operaciones
_______________________ test_aggregator_margen_correcto ________________________

sample_operaciones = [<Mock id='140392708456128'>, <Mock id='140392554190112'>, <Mock id='140392554478528'>, <Mock id='140392708452912'>, <Mock id='140392554192032'>]

    def test_aggregator_margen_correcto(sample_operaciones):
        """Test: Margen operativo correcto."""
        aggregator = MetricsAggregator(
            operaciones=sample_operaciones,
            fecha_inicio=date(2025, 10, 1),
            fecha_fin=date(2025, 10, 31)
        )
    
>       metricas = aggregator.aggregate_all()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_metrics_aggregator.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/metrics/metrics_aggregator.py:221: in aggregate_all
    series_temporales = self._calculate_series_temporales()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.metrics.metrics_aggregator.MetricsAggregator object at 0x7fafb1e52f60>

    def _calculate_series_temporales(self) -> Dict[str, Any]:
        """
        Calcula series temporales mensuales para grficos de lnea.
    
        Agrupa operaciones por mes y calcula:
        - Ingresos mensuales
        - Gastos mensuales
        - Utilidad mensual (ingresos - gastos)
    
        Returns:
            Dict con 4 listas:
            {
                'meses': ['Oct 2025', 'Nov 2025', ...],
                'ingresos_por_mes': [150000, 180000, ...],
                'gastos_por_mes': [50000, 60000, ...],
                'utilidad_por_mes': [100000, 120000, ...]
            }
        """
        from datetime import datetime
        from collections import defaultdict
        from app.models import TipoOperacion
    
        # Agrupar operaciones por mes
        ops_por_mes = defaultdict(lambda: {'ingresos': 0, 'gastos': 0})
    
        for op in self.operaciones:
            mes_key = op.fecha.strftime('%Y-%m')
    
            if op.tipo_operacion == TipoOperacion.INGRESO:
                ops_por_mes[mes_key]['ingresos'] += float(op.monto_uyu)
            elif op.tipo_operacion == TipoOperacion.GASTO:
                ops_por_mes[mes_key]['gastos'] += float(op.monto_uyu)
    
        # Ordenar por fecha
>       meses_ordenados = sorted(ops_por_mes.keys())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'Mock' and 'Mock'

app/services/metrics/metrics_aggregator.py:372: TypeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Iniciando agregacin de mtricas: 5 operaciones
------------------------------ Captured log call -------------------------------
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:126 Iniciando agregacin de mtricas: 5 operaciones
__________________________ test_aggregator_area_lider __________________________

sample_operaciones = [<Mock id='140392581158992'>, <Mock id='140392581161968'>, <Mock id='140392581163456'>, <Mock id='140392554189968'>, <Mock id='140392581161344'>]

    def test_aggregator_area_lider(sample_operaciones):
        """Test: Identifica rea lder."""
        aggregator = MetricsAggregator(
            operaciones=sample_operaciones,
            fecha_inicio=date(2025, 10, 1),
            fecha_fin=date(2025, 10, 31)
        )
    
>       metricas = aggregator.aggregate_all()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_metrics_aggregator.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/metrics/metrics_aggregator.py:221: in aggregate_all
    series_temporales = self._calculate_series_temporales()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.metrics.metrics_aggregator.MetricsAggregator object at 0x7fafb1eddeb0>

    def _calculate_series_temporales(self) -> Dict[str, Any]:
        """
        Calcula series temporales mensuales para grficos de lnea.
    
        Agrupa operaciones por mes y calcula:
        - Ingresos mensuales
        - Gastos mensuales
        - Utilidad mensual (ingresos - gastos)
    
        Returns:
            Dict con 4 listas:
            {
                'meses': ['Oct 2025', 'Nov 2025', ...],
                'ingresos_por_mes': [150000, 180000, ...],
                'gastos_por_mes': [50000, 60000, ...],
                'utilidad_por_mes': [100000, 120000, ...]
            }
        """
        from datetime import datetime
        from collections import defaultdict
        from app.models import TipoOperacion
    
        # Agrupar operaciones por mes
        ops_por_mes = defaultdict(lambda: {'ingresos': 0, 'gastos': 0})
    
        for op in self.operaciones:
            mes_key = op.fecha.strftime('%Y-%m')
    
            if op.tipo_operacion == TipoOperacion.INGRESO:
                ops_por_mes[mes_key]['ingresos'] += float(op.monto_uyu)
            elif op.tipo_operacion == TipoOperacion.GASTO:
                ops_por_mes[mes_key]['gastos'] += float(op.monto_uyu)
    
        # Ordenar por fecha
>       meses_ordenados = sorted(ops_por_mes.keys())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'Mock' and 'Mock'

app/services/metrics/metrics_aggregator.py:372: TypeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Iniciando agregacin de mtricas: 5 operaciones
------------------------------ Captured log call -------------------------------
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:126 Iniciando agregacin de mtricas: 5 operaciones
_______________________ test_aggregator_con_comparacion ________________________

sample_operaciones = [<Mock id='140392581168592'>, <Mock id='140392581168736'>, <Mock id='140392581166000'>, <Mock id='140392581160576'>, <Mock id='140392554473104'>]

    def test_aggregator_con_comparacion(sample_operaciones):
        """Test: Aggregator con perodo de comparacin."""
        # Operaciones comparacin (menores)
        ops_comp = []
        for i in range(2):
            op = Mock()
            op.tipo_operacion = TipoOperacion.INGRESO
            op.monto_uyu = Decimal('40000')
            op.monto_usd = Decimal('1000')
            op.area = Mock(nombre='Notarial')
            op.localidad = Mock(value='MONTEVIDEO')
            ops_comp.append(op)
    
        aggregator = MetricsAggregator(
            operaciones=sample_operaciones,
            fecha_inicio=date(2025, 10, 1),
            fecha_fin=date(2025, 10, 31),
            operaciones_comparacion=ops_comp
        )
    
>       metricas = aggregator.aggregate_all()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_metrics_aggregator.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/metrics/metrics_aggregator.py:221: in aggregate_all
    series_temporales = self._calculate_series_temporales()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.metrics.metrics_aggregator.MetricsAggregator object at 0x7fafb1edd580>

    def _calculate_series_temporales(self) -> Dict[str, Any]:
        """
        Calcula series temporales mensuales para grficos de lnea.
    
        Agrupa operaciones por mes y calcula:
        - Ingresos mensuales
        - Gastos mensuales
        - Utilidad mensual (ingresos - gastos)
    
        Returns:
            Dict con 4 listas:
            {
                'meses': ['Oct 2025', 'Nov 2025', ...],
                'ingresos_por_mes': [150000, 180000, ...],
                'gastos_por_mes': [50000, 60000, ...],
                'utilidad_por_mes': [100000, 120000, ...]
            }
        """
        from datetime import datetime
        from collections import defaultdict
        from app.models import TipoOperacion
    
        # Agrupar operaciones por mes
        ops_por_mes = defaultdict(lambda: {'ingresos': 0, 'gastos': 0})
    
        for op in self.operaciones:
            mes_key = op.fecha.strftime('%Y-%m')
    
            if op.tipo_operacion == TipoOperacion.INGRESO:
                ops_por_mes[mes_key]['ingresos'] += float(op.monto_uyu)
            elif op.tipo_operacion == TipoOperacion.GASTO:
                ops_por_mes[mes_key]['gastos'] += float(op.monto_uyu)
    
        # Ordenar por fecha
>       meses_ordenados = sorted(ops_por_mes.keys())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'Mock' and 'Mock'

app/services/metrics/metrics_aggregator.py:372: TypeError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Iniciando agregacin de mtricas: 5 operaciones
2025-12-18 11:33:53 - app.services.metrics.metrics_aggregator - INFO - Calculando mtricas de comparacin
------------------------------ Captured log call -------------------------------
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:126 Iniciando agregacin de mtricas: 5 operaciones
INFO     app.services.metrics.metrics_aggregator:metrics_aggregator.py:162 Calculando mtricas de comparacin
______________ TestMonthlyAggregator.test_aggregate_octubre_2025 _______________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb057cb30>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94f5c70>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057e210>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb057c590>
parameters = [{'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94f5c70>
cursor = <cursor object at 0x7fafb1ee56c0; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...iones \nWHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057e210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_monthly_aggregator.TestMonthlyAggregator object at 0x7fafb98a46e0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb94f5ac0>

    @pytest.mark.integration
    def test_aggregate_octubre_2025(self, db_session):
        """Test de integracin: agregar datos reales de octubre 2025"""
        aggregator = MonthlyAggregator(db_session)
        start = date(2025, 10, 1)
        end = date(2025, 10, 31)
    
>       resultado = aggregator.aggregate(start, end)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_monthly_aggregator.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/report_data/base_aggregator.py:73: in aggregate
    operaciones = self.fetch_operations(start_date, end_date, **kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app/services/report_data/base_aggregator.py:177: in fetch_operations
    return self.db.query(Operacion).filter(and_(*filtros)).all()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2673: in all
    return self._iter().all()  # type: ignore
           ^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb94f5c70>
cursor = <cursor object at 0x7fafb1ee56c0; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...iones \nWHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb057e210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^
E       
E       [SQL: SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha AS operaciones_fecha, operaciones.monto_original AS operaciones_monto_original, operaciones.moneda_original AS operaciones_moneda_original, operaciones.tipo_cambio AS operaciones_tipo_cambio, operaciones.monto_uyu AS operaciones_monto_uyu, operaciones.monto_usd AS operaciones_monto_usd, operaciones.area_id AS operaciones_area_id, operaciones.localidad AS operaciones_localidad, operaciones.descripcion AS operaciones_descripcion, operaciones.cliente AS operaciones_cliente, operaciones.proveedor AS operaciones_proveedor, operaciones.deleted_at AS operaciones_deleted_at, operaciones.created_at AS operaciones_created_at, operaciones.updated_at AS operaciones_updated_at 
E       FROM operaciones 
E       WHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL]
E       [parameters: {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.report_data.base_aggregator - INFO - Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
------------------------------ Captured log call -------------------------------
INFO     app.services.report_data.base_aggregator:base_aggregator.py:67 Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
__________ TestMonthlyAggregator.test_aggregate_con_filtro_localidad ___________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb1e52f30>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0525dc0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1e53d10>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb1e53650>
parameters = [{'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31), 'localidad_1': 'MONTEVIDEO'}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0525dc0>
cursor = <cursor object at 0x7fafb1ee6d40; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL AND operaciones.localidad = %(localidad_1)s'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31), 'localidad_1': 'MONTEVIDEO'}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1e53d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_monthly_aggregator.TestMonthlyAggregator object at 0x7fafb98a4890>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb0525ca0>

    @pytest.mark.integration
    def test_aggregate_con_filtro_localidad(self, db_session):
        """Agregar solo Montevideo"""
        aggregator = MonthlyAggregator(db_session)
        start = date(2025, 10, 1)
        end = date(2025, 10, 31)
    
>       resultado = aggregator.aggregate(start, end, localidad="Montevideo")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_monthly_aggregator.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/report_data/base_aggregator.py:73: in aggregate
    operaciones = self.fetch_operations(start_date, end_date, **kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app/services/report_data/base_aggregator.py:177: in fetch_operations
    return self.db.query(Operacion).filter(and_(*filtros)).all()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2673: in all
    return self._iter().all()  # type: ignore
           ^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb0525dc0>
cursor = <cursor object at 0x7fafb1ee6d40; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL AND operaciones.localidad = %(localidad_1)s'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31), 'localidad_1': 'MONTEVIDEO'}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb1e53d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^
E       
E       [SQL: SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha AS operaciones_fecha, operaciones.monto_original AS operaciones_monto_original, operaciones.moneda_original AS operaciones_moneda_original, operaciones.tipo_cambio AS operaciones_tipo_cambio, operaciones.monto_uyu AS operaciones_monto_uyu, operaciones.monto_usd AS operaciones_monto_usd, operaciones.area_id AS operaciones_area_id, operaciones.localidad AS operaciones_localidad, operaciones.descripcion AS operaciones_descripcion, operaciones.cliente AS operaciones_cliente, operaciones.proveedor AS operaciones_proveedor, operaciones.deleted_at AS operaciones_deleted_at, operaciones.created_at AS operaciones_created_at, operaciones.updated_at AS operaciones_updated_at 
E       FROM operaciones 
E       WHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL AND operaciones.localidad = %(localidad_1)s]
E       [parameters: {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31), 'localidad_1': 'MONTEVIDEO'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:53 - app.services.report_data.base_aggregator - INFO - Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
------------------------------ Captured log call -------------------------------
INFO     app.services.report_data.base_aggregator:base_aggregator.py:67 Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
____________ TestMonthlyAggregator.test_metricas_por_area_ordenadas ____________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb91bbc20>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4732960>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbec0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb91bb830>
parameters = [{'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4732960>
cursor = <cursor object at 0x7fafb05fb5b0; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...iones \nWHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbec0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_monthly_aggregator.TestMonthlyAggregator object at 0x7fafb98a4a40>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb1e50b30>

    @pytest.mark.integration
    def test_metricas_por_area_ordenadas(self, db_session):
        """reas deben estar ordenadas por ingresos desc"""
        aggregator = MonthlyAggregator(db_session)
        start = date(2025, 10, 1)
        end = date(2025, 10, 31)
    
>       resultado = aggregator.aggregate(start, end)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_monthly_aggregator.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/report_data/base_aggregator.py:73: in aggregate
    operaciones = self.fetch_operations(start_date, end_date, **kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app/services/report_data/base_aggregator.py:177: in fetch_operations
    return self.db.query(Operacion).filter(and_(*filtros)).all()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2673: in all
    return self._iter().all()  # type: ignore
           ^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafa4732960>
cursor = <cursor object at 0x7fafb05fb5b0; closed: -1>
statement = 'SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha ...iones \nWHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL'
parameters = {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb91bbec0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 2: FROM operaciones 
E                    ^
E       
E       [SQL: SELECT operaciones.id AS operaciones_id, operaciones.tipo_operacion AS operaciones_tipo_operacion, operaciones.fecha AS operaciones_fecha, operaciones.monto_original AS operaciones_monto_original, operaciones.moneda_original AS operaciones_moneda_original, operaciones.tipo_cambio AS operaciones_tipo_cambio, operaciones.monto_uyu AS operaciones_monto_uyu, operaciones.monto_usd AS operaciones_monto_usd, operaciones.area_id AS operaciones_area_id, operaciones.localidad AS operaciones_localidad, operaciones.descripcion AS operaciones_descripcion, operaciones.cliente AS operaciones_cliente, operaciones.proveedor AS operaciones_proveedor, operaciones.deleted_at AS operaciones_deleted_at, operaciones.created_at AS operaciones_created_at, operaciones.updated_at AS operaciones_updated_at 
E       FROM operaciones 
E       WHERE operaciones.fecha >= %(fecha_1)s AND operaciones.fecha <= %(fecha_2)s AND operaciones.deleted_at IS NULL]
E       [parameters: {'fecha_1': datetime.date(2025, 10, 1), 'fecha_2': datetime.date(2025, 10, 31)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2025-12-18 11:33:54 - app.services.report_data.base_aggregator - INFO - Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
------------------------------ Captured log call -------------------------------
INFO     app.services.report_data.base_aggregator:base_aggregator.py:67 Agregando datos para MonthlyAggregator: 2025-10-01 a 2025-10-31
__________________ TestCrearRetiro.test_crear_retiro_solo_uyu __________________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9416270>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414770>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94169c0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb9417440>
parameters = [{'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 190469, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414770>
cursor = <cursor object at 0x7fafb949ce50; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 190469, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94169c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_operacion_service.TestCrearRetiro object at 0x7fafb98a6a80>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb9417350>

    @pytest.mark.integration
    def test_crear_retiro_solo_uyu(self, db_session):
        """Retiro solo en UYU debe calcular USD"""
        data = RetiroCreate(
            monto_uyu=Decimal('10000'),
            monto_usd=None,
            tipo_cambio=Decimal('40.00'),
            fecha=date.today(),
            localidad='Montevideo',
            descripcion='Retiro efectivo Bruno'
        )
    
>       operacion = crear_retiro(db_session, data)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/operacion_service.py:118: in crear_retiro
    db.commit()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414770>
cursor = <cursor object at 0x7fafb949ce50; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 190469, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb94169c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^
E       
E       [SQL: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_usd, area_id, localidad, descripcion, cliente, proveedor, deleted_at, created_at, updated_at) VALUES (%(id)s::UUID, %(tipo_operacion)s, %(fecha)s, %(monto_original)s, %(moneda_original)s, %(tipo_cambio)s, %(monto_uyu)s, %(monto_usd)s, %(area_id)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'id': UUID('7e2beefa-3c7c-4176-be7a-bcf6dbdb4517'), 'tipo_operacion': 'RETIRO', 'fecha': datetime.date(2025, 12, 18), 'monto_original': Decimal('10000'), 'moneda_original': 'UYU', 'tipo_cambio': Decimal('40.00'), 'monto_uyu': Decimal('10000'), 'monto_usd': Decimal('2.5E+2'), 'area_id': None, 'localidad': 'MONTEVIDEO', 'descripcion': 'Retiro efectivo Bruno', 'cliente': None, 'proveedor': None, 'deleted_at': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 190469, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 190474, tzinfo=datetime.timezone.utc)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
__________________ TestCrearRetiro.test_crear_retiro_solo_usd __________________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb94167e0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414740>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9416d80>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb9414950>
parameters = [{'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 848061, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414740>
cursor = <cursor object at 0x7fafb9609210; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 848061, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9416d80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_operacion_service.TestCrearRetiro object at 0x7fafb98a7d10>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb9415820>

    @pytest.mark.integration
    def test_crear_retiro_solo_usd(self, db_session):
        """Retiro solo en USD debe calcular UYU"""
        data = RetiroCreate(
            monto_uyu=None,
            monto_usd=Decimal('500'),
            tipo_cambio=Decimal('40.00'),
            fecha=date.today(),
            localidad='Mercedes',
            descripcion='Retiro USD Agustina'
        )
    
>       operacion = crear_retiro(db_session, data)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/operacion_service.py:118: in crear_retiro
    db.commit()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9414740>
cursor = <cursor object at 0x7fafb9609210; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 848061, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9416d80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^
E       
E       [SQL: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_usd, area_id, localidad, descripcion, cliente, proveedor, deleted_at, created_at, updated_at) VALUES (%(id)s::UUID, %(tipo_operacion)s, %(fecha)s, %(monto_original)s, %(moneda_original)s, %(tipo_cambio)s, %(monto_uyu)s, %(monto_usd)s, %(area_id)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'id': UUID('a677a4cd-64f5-445b-b494-c98342582818'), 'tipo_operacion': 'RETIRO', 'fecha': datetime.date(2025, 12, 18), 'monto_original': Decimal('500'), 'moneda_original': 'USD', 'tipo_cambio': Decimal('40.00'), 'monto_uyu': Decimal('20000.00'), 'monto_usd': Decimal('500'), 'area_id': None, 'localidad': 'MERCEDES', 'descripcion': 'Retiro USD Agustina', 'cliente': None, 'proveedor': None, 'deleted_at': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 848061, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2025, 12, 18, 14, 33, 58, 848091, tzinfo=datetime.timezone.utc)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
_______________ TestCrearRetiro.test_crear_retiro_ambas_monedas ________________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb93c7830>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c4a10>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c5dc0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb93c4bf0>
parameters = [{'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 59, 505243, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c4a10>
cursor = <cursor object at 0x7fafb949f1f0; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 59, 505243, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c5dc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_operacion_service.TestCrearRetiro object at 0x7fafb98a7ec0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb93c7e90>

    @pytest.mark.integration
    def test_crear_retiro_ambas_monedas(self, db_session):
        """Retiro con ambos montos debe usar valores exactos"""
        data = RetiroCreate(
            monto_uyu=Decimal('12000'),
            monto_usd=Decimal('300'),
            tipo_cambio=Decimal('40.00'),
            fecha=date.today(),
            localidad='Montevideo',
            descripcion='Retiro mixto'
        )
    
>       operacion = crear_retiro(db_session, data)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/operacion_service.py:118: in crear_retiro
    db.commit()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb93c4a10>
cursor = <cursor object at 0x7fafb949f1f0; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 59, 505243, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb93c5dc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^
E       
E       [SQL: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_usd, area_id, localidad, descripcion, cliente, proveedor, deleted_at, created_at, updated_at) VALUES (%(id)s::UUID, %(tipo_operacion)s, %(fecha)s, %(monto_original)s, %(moneda_original)s, %(tipo_cambio)s, %(monto_uyu)s, %(monto_usd)s, %(area_id)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'id': UUID('b3b72b5f-26e6-4476-940e-ae28c8a38381'), 'tipo_operacion': 'RETIRO', 'fecha': datetime.date(2025, 12, 18), 'monto_original': Decimal('12000'), 'moneda_original': 'UYU', 'tipo_cambio': Decimal('40.00'), 'monto_uyu': Decimal('12000'), 'monto_usd': Decimal('300'), 'area_id': None, 'localidad': 'MONTEVIDEO', 'descripcion': 'Retiro mixto', 'cliente': None, 'proveedor': None, 'deleted_at': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 33, 59, 505243, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2025, 12, 18, 14, 33, 59, 505248, tzinfo=datetime.timezone.utc)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
______________ TestCrearRetiro.test_crear_retiro_no_requiere_area ______________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb9402060>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9403560>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9402ff0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb9402870>
parameters = [{'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 34, 0, 160994, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9403560>
cursor = <cursor object at 0x7fafb94354e0; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 34, 0, 160994, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9402ff0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_operacion_service.TestCrearRetiro object at 0x7fafb96d00b0>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb9400980>

    @pytest.mark.integration
    def test_crear_retiro_no_requiere_area(self, db_session):
        """Retiro NO requiere rea - solo localidad (lgica de negocio correcta)"""
        data = RetiroCreate(
            monto_uyu=Decimal('5000'),
            monto_usd=None,
            tipo_cambio=Decimal('40.00'),
            fecha=date.today(),
            localidad='Montevideo',
            descripcion='Test'
        )
    
>       operacion = crear_retiro(db_session, data)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/operacion_service.py:118: in crear_retiro
    db.commit()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2028: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1288: in _prepare_impl
    self.session.flush()
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4352: in flush
    self._flush(objects)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4487: in _flush
    with util.safe_reraise():
venv/lib/python3.12/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:4448: in _flush
    flush_context.execute()
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
venv/lib/python3.12/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
venv/lib/python3.12/site-packages/sqlalchemy/orm/persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9403560>
cursor = <cursor object at 0x7fafb94354e0; closed: -1>
statement = 'INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_us...d)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)'
parameters = {'area_id': None, 'cliente': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 34, 0, 160994, tzinfo=datetime.timezone.utc), 'deleted_at': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb9402ff0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "operaciones" does not exist
E       LINE 1: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_or...
E                           ^
E       
E       [SQL: INSERT INTO operaciones (id, tipo_operacion, fecha, monto_original, moneda_original, tipo_cambio, monto_uyu, monto_usd, area_id, localidad, descripcion, cliente, proveedor, deleted_at, created_at, updated_at) VALUES (%(id)s::UUID, %(tipo_operacion)s, %(fecha)s, %(monto_original)s, %(moneda_original)s, %(tipo_cambio)s, %(monto_uyu)s, %(monto_usd)s, %(area_id)s::UUID, %(localidad)s, %(descripcion)s, %(cliente)s, %(proveedor)s, %(deleted_at)s, %(created_at)s, %(updated_at)s)]
E       [parameters: {'id': UUID('30a6d464-c67c-4292-8cde-a393c6c42f6f'), 'tipo_operacion': 'RETIRO', 'fecha': datetime.date(2025, 12, 18), 'monto_original': Decimal('5000'), 'moneda_original': 'UYU', 'tipo_cambio': Decimal('40.00'), 'monto_uyu': Decimal('5000'), 'monto_usd': Decimal('125'), 'area_id': None, 'localidad': 'MONTEVIDEO', 'descripcion': 'Test', 'cliente': None, 'proveedor': None, 'deleted_at': None, 'created_at': datetime.datetime(2025, 12, 18, 14, 34, 0, 160994, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2025, 12, 18, 14, 34, 0, 161000, tzinfo=datetime.timezone.utc)}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
________ TestFiltrosPorLocalidadArea.test_filtrar_operaciones_por_area _________

self = <sqlalchemy.engine.base.Connection object at 0x7fafb914a570>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9149070>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05507a0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x7fafb0550950>
parameters = [{'nombre_1': 'Jurdica', 'param_1': 1}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9149070>
cursor = <cursor object at 0x7fafb94aad40; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05507a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UndefinedTable: relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: UndefinedTable

The above exception was the direct cause of the following exception:

self = <tests.test_operacion_service.TestFiltrosPorLocalidadArea object at 0x7fafb96d1b80>
db_session = <sqlalchemy.orm.session.Session object at 0x7fafb91491c0>

    @pytest.mark.integration
    def test_filtrar_operaciones_por_area(self, db_session):
        """Filtrar operaciones por rea especfica"""
        # Obtener dos reas diferentes
>       area1 = db_session.query(Area).filter(Area.nombre == "Jurdica").first()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_operacion_service.py:739: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2728: in first
    return self.limit(1)._iter().first()  # type: ignore
           ^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2827: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2362: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2247: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:305: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1418: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:515: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1640: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1846: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x7fafb9149070>
cursor = <cursor object at 0x7fafb94aad40; closed: -1>
statement = 'SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS ar...created_at, areas.updated_at AS areas_updated_at \nFROM areas \nWHERE areas.nombre = %(nombre_1)s \n LIMIT %(param_1)s'
parameters = {'nombre_1': 'Jurdica', 'param_1': 1}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x7fafb05507a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation "areas" does not exist
E       LINE 2: FROM areas 
E                    ^
E       
E       [SQL: SELECT areas.id AS areas_id, areas.nombre AS areas_nombre, areas.descripcion AS areas_descripcion, areas.activo AS areas_activo, areas.created_at AS areas_created_at, areas.updated_at AS areas_updated_at 
E       FROM areas 
E       WHERE areas.nombre = %(nombre_1)s 
E        LIMIT %(param_1)s]
E       [parameters: {'nombre_1': 'Jurdica', 'param_1': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:941: ProgrammingError
______ TestCreateAccessToken.test_create_access_token_expiracion_correcta ______

self = <tests.test_security.TestCreateAccessToken object at 0x7fafb96f2570>
mock_settings = <MagicMock name='settings' id='140392551727520'>

    @patch('app.core.security.settings')
    def test_create_access_token_expiracion_correcta(self, mock_settings):
        """La expiracin debe ser aproximadamente en X minutos"""
        # Arrange
        mock_settings.secret_key = "test_secret_key_12345"
        mock_settings.algorithm = "HS256"
        mock_settings.access_token_expire_minutes = 60  # 1 hora
    
        data = {"sub": "user123"}
        ahora = datetime.now(timezone.utc)
    
        # Act
        token = create_access_token(data)
    
        # Decode
        decoded = jwt.decode(token, mock_settings.secret_key, algorithms=[mock_settings.algorithm])
    
        # Assert
        exp_datetime = datetime.utcfromtimestamp(decoded["exp"])
>       diferencia = exp_datetime - ahora
                     ^^^^^^^^^^^^^^^^^^^^
E       TypeError: can't subtract offset-naive and offset-aware datetimes

tests/test_security.py:252: TypeError
__________ TestFuncionesGlobales.test_generar_sql_inteligente_wrapper __________

self = <Mock name='get_sql_router().generar_sql_inteligente' id='140392703156368'>
args = ('Test',), kwargs = {}, expected = call('Test')
actual = call('Test', contexto=None)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fafb8e01080>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: generar_sql_inteligente('Test')
E             Actual: generar_sql_inteligente('Test', contexto=None)

/usr/lib/python3.12/unittest/mock.py:944: AssertionError

During handling of the above exception, another exception occurred:

self = <Mock name='get_sql_router().generar_sql_inteligente' id='140392703156368'>
args = ('Test',), kwargs = {}

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
            raise AssertionError(msg)
>       return self.assert_called_with(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: expected call not found.
E       Expected: generar_sql_inteligente('Test')
E         Actual: generar_sql_inteligente('Test', contexto=None)
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'contexto': None} == {}
E         
E         Left contains 1 more item:
E         {'contexto': None}
E         Use -v to get more diff

/usr/lib/python3.12/unittest/mock.py:956: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.test_sql_router.TestFuncionesGlobales object at 0x7fafb974a090>
mock_get_router = <MagicMock name='get_sql_router' id='140392703152528'>

    @patch('app.services.sql_router.get_sql_router')
    def test_generar_sql_inteligente_wrapper(self, mock_get_router):
        """Funcin wrapper debe llamar a get_sql_router"""
        # Arrange
        mock_router = Mock()
        mock_router.generar_sql_inteligente.return_value = {
            'sql': 'SELECT * FROM ops',
            'exito': True
        }
        mock_get_router.return_value = mock_router
    
        pregunta = "Test"
    
        # Act
        resultado = generar_sql_inteligente(pregunta)
    
        # Assert
        mock_get_router.assert_called_once()
>       mock_router.generar_sql_inteligente.assert_called_once_with(pregunta)
E       AssertionError: expected call not found.
E       Expected: generar_sql_inteligente('Test')
E         Actual: generar_sql_inteligente('Test', contexto=None)
E       
E       pytest introspection follows:
E       
E       Kwargs:
E       assert {'contexto': None} == {}
E         
E         Left contains 1 more item:
E         {'contexto': None}
E         Use -v to get more diff

tests/test_sql_router.py:512: AssertionError
=============================== warnings summary ===============================
venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291: 12 warnings
  /home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/pydantic/_internal/_config.py:291: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.9/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

app/core/database.py:9
  /home/brunogandolfo/cfo-inteligente/backend/app/core/database.py:9: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854
  /home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/passlib/utils/__init__.py:854: DeprecationWarning: 'crypt' is deprecated and slated for removal in Python 3.13
    from crypt import crypt as _crypt

tests/test_e2e.py:69
  /home/brunogandolfo/cfo-inteligente/backend/tests/test_e2e.py:69: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/test_e2e.py:105
  /home/brunogandolfo/cfo-inteligente/backend/tests/test_e2e.py:105: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/test_e2e.py:380
  /home/brunogandolfo/cfo-inteligente/backend/tests/test_e2e.py:380: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/test_security.py::TestCreateAccessToken::test_create_access_token_contiene_datos
tests/test_security.py::TestCreateAccessToken::test_create_access_token_contiene_exp
tests/test_security.py::TestCreateAccessToken::test_create_access_token_expiracion_correcta
  /home/brunogandolfo/cfo-inteligente/backend/venv/lib/python3.12/site-packages/jose/jwt.py:311: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    now = timegm(datetime.utcnow().utctimetuple())

tests/test_security.py::TestCreateAccessToken::test_create_access_token_expiracion_correcta
  /home/brunogandolfo/cfo-inteligente/backend/tests/test_security.py:251: DeprecationWarning: datetime.datetime.utcfromtimestamp() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.fromtimestamp(timestamp, datetime.UTC).
    exp_datetime = datetime.utcfromtimestamp(decoded["exp"])

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.12.3-final-0 ________________

Name                                                             Stmts   Miss  Cover   Missing
----------------------------------------------------------------------------------------------
app/__init__.py                                                      0      0   100%
app/api/__init__.py                                                  0      0   100%
app/api/auth.py                                                     59     18    69%   80-110, 127-144
app/api/catalogos.py                                                30      4    87%   44-45, 54-55
app/api/cfo_ai.py                                                  135     98    27%   44-103, 110-279, 300-302, 320-330, 340-353
app/api/cfo_streaming.py                                           138    103    25%   43, 56-64, 78-292
app/api/endpoints/reports.py                                        97     62    36%   109-170, 199-249, 273-279, 327-379
app/api/frases_motivacionales.py                                    23     12    48%   33-66
app/api/operaciones.py                                             112     74    34%   34-62, 71-87, 91, 95, 99-101, 105-107, 117-191, 195-199, 203-207
app/api/reportes.py                                                 82     64    22%   17-22, 32-60, 78-109, 119-149, 183-231
app/api/reportes_dashboard.py                                       40     30    25%   21-73
app/api/tipo_cambio.py                                              14      5    64%   12, 19-20, 32-33
app/core/__init__.py                                                 0      0   100%
app/core/config.py                                                  17      0   100%
app/core/constants.py                                               46      0   100%
app/core/database.py                                                12      0   100%
app/core/dependencies.py                                            61     41    33%   43-47, 72-85, 105-144, 170-172, 187-192, 213-215, 244-246, 269-273, 289-311
app/core/exceptions.py                                              24      7    71%   41-42, 53, 88-89, 96, 107
app/core/logger.py                                                  29      1    97%   49
app/core/security.py                                                37     14    62%   41-71
app/main.py                                                         34      4    88%   33, 37, 53-54
app/models/__init__.py                                               9      0   100%
app/models/area.py                                                  16      1    94%   9
app/models/cliente.py                                               15      1    93%   8
app/models/conversacion.py                                          26      0   100%
app/models/distribucion.py                                          19      1    95%   9
app/models/operacion.py                                             39      0   100%
app/models/proveedor.py                                             15      1    93%   8
app/models/socio.py                                                 15      1    93%   8
app/models/usuario.py                                               19      0   100%
app/repositories/__init__.py                                         2      0   100%
app/repositories/base_repository.py                                 16      4    75%   36, 49, 63, 76
app/repositories/operations_repository.py                           63     46    27%   56, 72, 95-102, 138-171, 196-230, 251-262, 293-304, 316-331
app/schemas/__init__.py                                              0      0   100%
app/schemas/conversacion.py                                         34      0   100%
app/schemas/operacion.py                                            82     16    80%   17, 31-33, 42-44, 57-59, 68-70, 80, 82, 84
app/schemas/operacion_update.py                                     60     15    75%   26-28, 33-35, 52-54, 59-61, 76-78
app/schemas/report/__init__.py                                       4      0   100%
app/schemas/report/metrics.py                                       52      0   100%
app/schemas/report/request.py                                       29      3    90%   39-41
app/schemas/report/response.py                                      30      0   100%
app/services/__init__.py                                             0      0   100%
app/services/ai/__init__.py                                          7      0   100%
app/services/ai/ai_orchestrator.py                                 118      4    97%   79-80, 89-90
app/services/ai/base_insight_generator.py                           33     18    45%   43, 63, 81, 100, 126-155
app/services/ai/claude_client.py                                    54     39    28%   78-97, 127-148, 178-208, 217-229
app/services/ai/comparativo_generator.py                            44     28    36%   64-66, 81, 96-104, 116, 138-141, 163-199
app/services/ai/estrategico_generator.py                            38     23    39%   53-54, 66, 81-89, 101, 120-150
app/services/ai/fallback_generator.py                              111     74    33%   41-42, 58-63, 75-76, 81-82, 90, 119-190, 213-289
app/services/ai/insights_orchestrator.py                            45     34    24%   60-65, 96-149, 168-181
app/services/ai/operativo_generator.py                              37     22    41%   50-51, 65, 82-88, 107, 126-156
app/services/ai/prompt_builder.py                                   42     36    14%   28-87, 103-164, 187-253, 265
app/services/ai/response_parser.py                                  77     28    64%   68-69, 79-85, 128-151, 195-208
app/services/analytics/__init__.py                                   3      0   100%
app/services/analytics/anomaly_detector.py                          51     42    18%   47-49, 66-139, 143-157, 170-191
app/services/analytics/variance_detector.py                         86     75    13%   43-45, 62-133, 144-175, 180-186, 194-212, 217-241
app/services/cfo_ai_service.py                                      12      8    33%   13-28
app/services/chain_of_thought_sql.py                                72     38    47%   128-173, 212-234, 259-282
app/services/charts/__init__.py                                     13      0   100%
app/services/charts/bar_chart.py                                    52     36    31%   42, 48, 51, 58, 60, 62, 69-140
app/services/charts/base_chart.py                                   84     49    42%   125-140, 152, 160, 172-228, 248-268, 286-346, 372-380
app/services/charts/chart_factory.py                                34      5    85%   100-101, 106-109
app/services/charts/combo_chart.py                                  56     36    36%   70, 73, 81, 83, 85, 94, 96, 98, 110-209
app/services/charts/donut_chart.py                                  35     24    31%   55, 58, 61, 67, 71, 80-169
app/services/charts/funnel_chart.py                                 32     26    19%   49-66, 75-137
app/services/charts/gauge_chart.py                                  23     17    26%   44-49, 58-129
app/services/charts/heatmap_chart.py                                56     36    36%   66, 73, 84, 86, 98-143, 164-185, 197, 215-220
app/services/charts/line_chart.py                                   38     23    39%   41, 44, 47, 50, 55, 57, 66-129
app/services/charts/pie_chart.py                                    23     11    52%   31, 34, 37, 43, 51-79
app/services/charts/treemap_chart.py                                22     16    27%   55-71, 80-119
app/services/charts/waterfall_chart.py                              34     16    53%   56, 64, 85-152, 169-179
app/services/claude_sql_generator.py                                34     11    68%   391-396, 407-408, 420-422
app/services/conversacion_service.py                                42      0   100%
app/services/insights/__init__.py                                    5      5     0%   11-16
app/services/insights/analysis_lenses.py                            29     29     0%   11-186
app/services/insights/insight_context_builder.py                    45     45     0%   11-143
app/services/insights/insight_formatter.py                          21     21     0%   11-93
app/services/insights/insight_generator.py                          41     41     0%   11-158
app/services/metrics/__init__.py                                     9      0   100%
app/services/metrics/base_calculator.py                             12      2    83%   59, 77
app/services/metrics/cliente_analyzer.py                            89      9    90%   46, 124, 137, 139, 167, 174-175, 177-178
app/services/metrics/distribution_calculator.py                     54     13    76%   90, 118, 159-174
app/services/metrics/efficiency_calculator.py                       26      1    96%   78
app/services/metrics/localidad_analyzer.py                          52      7    87%   54, 108-109, 139, 141, 143, 154
app/services/metrics/metrics_aggregator.py                         107     37    65%   178-180, 183-185, 227-285, 304-310, 328-333, 375-394
app/services/metrics/ratios_calculator.py                           53      3    94%   73, 135, 171
app/services/metrics/results_calculator.py                          14      0   100%
app/services/metrics/totals_calculator.py                           17      0   100%
app/services/metrics/trends_calculator.py                           87     20    77%   111, 147, 205-211, 224-230, 243-249, 275, 321-323
app/services/operacion_service.py                                   60     29    52%   30-50, 53, 67, 119-120, 130-192
app/services/pdf/__init__.py                                         4      0   100%
app/services/pdf/asset_manager.py                                   15     15     0%   10-55
app/services/pdf/pdf_compiler.py                                    75     60    20%   53-55, 88-128, 149-174, 192-225, 237-261
app/services/pdf/pdf_compiler_playwright.py                         70     54    23%   55, 77-145, 167-218, 230-234, 247, 263-270
app/services/pdf/pdf_generator.py                                   30     30     0%   10-81
app/services/pdf/pdf_metadata.py                                    31     31     0%   18-158
app/services/pdf/report_builder.py                                 122     95    22%   77-87, 121-220, 245-316, 320, 376, 406, 425-457, 461-463, 482-501, 513-518, 523-527, 531-535, 549-555
app/services/pdf/template_renderer.py                               60     48    20%   51-67, 80-108, 134-150, 165-177, 189-198
app/services/pdf/weasyprint_generator.py                            65     65     0%   8-118
app/services/query_fallback.py                                      31      3    90%   24, 42, 45
app/services/report_data/__init__.py                                 4      0   100%
app/services/report_data/aggregator_factory.py                      22     10    55%   41, 56-65, 76-79, 84
app/services/report_data/base_aggregator.py                        159    121    24%   74-96, 120, 128, 145, 187-218, 242-284, 288-324, 328-375, 389-440, 463-489, 497
app/services/report_data/generators/__init__.py                      2      2     0%   1-3
app/services/report_data/generators/pnl_localidad_generator.py     114    114     0%   7-429
app/services/report_data/monthly_aggregator.py                      56     34    39%   62, 82-108, 126-150, 161-181
app/services/report_orchestrator.py                                260    231    11%   95-106, 134-377, 395-591, 599-606, 623-637, 650-668, 672-675, 680-693
app/services/sql_post_processor.py                                  51      0   100%
app/services/sql_router.py                                         190     37    81%   111, 169, 179, 193-194, 254, 337, 349, 542, 602-644
app/services/tipo_cambio_service.py                                 31      1    97%   85
app/services/validador_canonico.py                                  89     72    19%   263-271, 289-301, 324-364, 399-467, 490
app/services/validador_sql.py                                      230     71    69%   86, 92, 139, 158, 192, 203, 209, 220, 231, 253, 266, 307-338, 434-435, 459-484, 514-593
app/services/validators/__init__.py                                  0      0   100%
app/services/validators/data_validator.py                           55     28    49%   71-102, 137-138, 163-185
app/services/validators/request_validator.py                        67     30    55%   38-50, 72, 80, 85, 92, 110-144, 164, 172, 212, 224, 247
app/utils/date_resolver.py                                          77     20    74%   56, 64-68, 71, 79, 109-111, 127-134, 170, 172, 174, 178, 224
app/utils/formatters.py                                             49      5    90%   105, 156-157, 165, 195
app/utils/narrative_builder.py                                     137    130     5%   24-90, 103-139, 152-189, 202-245, 258-311
app/utils/stats_calculator.py                                       53      0   100%
----------------------------------------------------------------------------------------------
TOTAL                                                             5813   2970    49%
Coverage HTML written to dir htmlcov
=========================== short test summary info ============================
FAILED tests/test_ai_components.py::test_fallback_estrategico_genera_insights
FAILED tests/test_ai_components.py::test_fallback_estrategico_identifica_disparidad
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_exitoso_crea_usuario
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_email_duplicado_retorna_400
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_asigna_rol_socio_si_email_autorizado
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_asigna_rol_colaborador_si_email_no_autorizado
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_password_se_hashea
FAILED tests/test_auth_endpoints.py::TestRegister::test_register_usuario_activo_por_defecto
FAILED tests/test_auth_endpoints.py::TestAuthValidation::test_register_email_invalido_retorna_422
FAILED tests/test_auth_endpoints.py::TestAuthValidation::test_register_sin_nombre_retorna_422
FAILED tests/test_auth_endpoints.py::TestSociosAutorizados::test_todos_los_socios_autorizados_son_socios[aborio]
FAILED tests/test_auth_endpoints.py::TestSociosAutorizados::test_todos_los_socios_autorizados_son_socios[falgorta]
FAILED tests/test_auth_endpoints.py::TestSociosAutorizados::test_todos_los_socios_autorizados_son_socios[vcaresani]
FAILED tests/test_auth_endpoints.py::TestSociosAutorizados::test_todos_los_socios_autorizados_son_socios[gtaborda]
FAILED tests/test_auth_endpoints.py::TestSociosAutorizados::test_prefijo_case_insensitive
FAILED tests/test_claude_sql_generator.py::TestInicializacion::test_init_con_api_key_valida
FAILED tests/test_claude_sql_generator.py::TestInicializacion::test_init_sin_api_key
FAILED tests/test_claude_sql_generator.py::TestInicializacion::test_business_context_con_8_reglas
FAILED tests/test_claude_sql_generator.py::TestGenerarSQL::test_generar_sql_error_api
FAILED tests/test_claude_sql_generator.py::TestGenerarSQL::test_generar_sql_timeout
FAILED tests/test_claude_sql_generator.py::TestGenerarSQL::test_generar_sql_rate_limit
FAILED tests/test_claude_sql_generator.py::TestGenerarSQL::test_generar_sql_parametros_correctos
FAILED tests/test_claude_sql_generator.py::TestContextoYPrompt::test_prompt_incluye_ddl
FAILED tests/test_claude_sql_generator.py::TestContextoYPrompt::test_prompt_incluye_business_context
FAILED tests/test_claude_sql_generator.py::TestContextoYPrompt::test_prompt_incluye_pregunta_usuario
FAILED tests/test_claude_sql_generator.py::TestManejoErrores::test_api_connection_error
FAILED tests/test_claude_sql_generator.py::TestManejoErrores::test_authentication_error
FAILED tests/test_claude_sql_generator.py::TestManejoErrores::test_respuesta_sin_content
FAILED tests/test_integration.py::TestChainOfThoughtIntegration::test_obtener_metadatos_temporales
FAILED tests/test_integration.py::TestChainOfThoughtIntegration::test_generar_con_cot_completo
FAILED tests/test_integration.py::TestEndpointCFOAsk::test_endpoint_pregunta_simple
FAILED tests/test_integration.py::TestEndpointCFOAsk::test_endpoint_pregunta_compleja
FAILED tests/test_integration.py::TestEndpointCFOAsk::test_endpoint_sql_invalido
FAILED tests/test_integration.py::TestEndpointCFOAsk::test_endpoint_formato_response
FAILED tests/test_integration.py::TestSQLRouterIntegration::test_sql_ejecutable_en_bd
FAILED tests/test_integration.py::TestSQLRouterIntegration::test_sql_rentabilidad_ejecutable
FAILED tests/test_integration.py::TestValidadorConDatosReales::test_validar_rentabilidad_real
FAILED tests/test_integration.py::TestValidadorConDatosReales::test_validar_distribuciones_reales
FAILED tests/test_integration.py::TestFlujoCompletoEndToEnd::test_flujo_completo_pregunta_facturacion
FAILED tests/test_integration.py::TestFlujoCompletoEndToEnd::test_flujo_con_validacion_pre_sql
FAILED tests/test_integration.py::TestFlujoCompletoEndToEnd::test_flujo_con_chain_of_thought
FAILED tests/test_integration.py::TestQueriesReales::test_query_conteo_operaciones
FAILED tests/test_integration.py::TestQueriesReales::test_query_sum_ingresos
FAILED tests/test_integration.py::TestQueriesReales::test_query_distribuciones_por_socio
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_proyeccion_fin_ao_con_metadatos
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_comparacion_mes_vs_mes
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_tendencia_ultimos_3_meses
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_conversion_moneda_multiple
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_metadatos_fecha_actual_correcta
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_meses_con_datos_dinamico
FAILED tests/test_integration.py::TestChainOfThoughtAvanzado::test_ultimo_mes_con_datos
FAILED tests/test_integration.py::TestValidadorPostSQLReal::test_porcentaje_usd_uyu_real
FAILED tests/test_integration.py::TestValidadorPostSQLReal::test_distribucion_por_socio_real
FAILED tests/test_integration.py::TestCasosCriticos::test_caso_retiros_por_socio
FAILED tests/test_integration.py::TestCasosCriticos::test_caso_comparacion_ao_anterior
FAILED tests/test_integration.py::TestCasosCriticos::test_caso_gonzalo_recibe_correcto
FAILED tests/test_integration.py::TestCasosCriticos::test_caso_estamos_creciendo
FAILED tests/test_integration_real.py::TestAuthIntegration::test_registro_y_login_flujo_completo
FAILED tests/test_integration_real.py::TestAuthIntegration::test_registro_socio_autorizado
FAILED tests/test_integration_real.py::TestAuthIntegration::test_registro_colaborador
FAILED tests/test_metrics_aggregator.py::test_aggregator_calcula_todas_metricas
FAILED tests/test_metrics_aggregator.py::test_aggregator_totals_correctos - T...
FAILED tests/test_metrics_aggregator.py::test_aggregator_margen_correcto - Ty...
FAILED tests/test_metrics_aggregator.py::test_aggregator_area_lider - TypeErr...
FAILED tests/test_metrics_aggregator.py::test_aggregator_con_comparacion - Ty...
FAILED tests/test_monthly_aggregator.py::TestMonthlyAggregator::test_aggregate_octubre_2025
FAILED tests/test_monthly_aggregator.py::TestMonthlyAggregator::test_aggregate_con_filtro_localidad
FAILED tests/test_monthly_aggregator.py::TestMonthlyAggregator::test_metricas_por_area_ordenadas
FAILED tests/test_operacion_service.py::TestCrearRetiro::test_crear_retiro_solo_uyu
FAILED tests/test_operacion_service.py::TestCrearRetiro::test_crear_retiro_solo_usd
FAILED tests/test_operacion_service.py::TestCrearRetiro::test_crear_retiro_ambas_monedas
FAILED tests/test_operacion_service.py::TestCrearRetiro::test_crear_retiro_no_requiere_area
FAILED tests/test_operacion_service.py::TestFiltrosPorLocalidadArea::test_filtrar_operaciones_por_area
FAILED tests/test_security.py::TestCreateAccessToken::test_create_access_token_expiracion_correcta
FAILED tests/test_sql_router.py::TestFuncionesGlobales::test_generar_sql_inteligente_wrapper
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto facturamos este mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo viene la rentabilidad?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l es el margen de este mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfEstamos mejor que el mes pasado?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo vamos en el a\xf1o?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto ganamos este trimestre?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l es la rentabilidad del \xe1rea Jur\xeddi]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea es m\xe1s rentable?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo est\xe1 la rentabilidad de Notarial?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[Dame un resumen del mes] - At...
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l fue el mejor mes del a\xf1o?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfVenimos mejorando la rentabilidad?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto es el resultado operativo?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo viene el margen comparado con el a]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfProyectamos bien el cierre de a\xf1o?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto le toca a Bruno este a\xf1o?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto recibi\xf3 Agustina en distribucion]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 socio retir\xf3 m\xe1s plata?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1ndo fue la \xfaltima distribuci\xf3n?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto se distribuy\xf3 este trimestre?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfEst\xe1n bien los porcentajes de cada soci]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto llev\xf3 Viviana en el a\xf1o?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 socio tiene m\xe1s retiros?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto se reparti\xf3 en total?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfGonzalo est\xe1 recibiendo lo que correspo]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfFacturamos m\xe1s este mes que el anterior]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo se compara este trimestre con el p]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfEstamos creciendo o bajando?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 trimestre fue mejor?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo va octubre comparado con septiembr]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfMejoramos respecto al a\xf1o pasado?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l fue el peor mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfLa tendencia es positiva o negativa?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfEstamos en alza o en baja?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo viene la facturaci\xf3n mes a mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto facturamos en d\xf3lares este mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto gastamos en pesos?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 porcentaje de facturaci\xf3n es en USD]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto se distribuy\xf3 en d\xf3lares?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfOperamos m\xe1s en pesos o d\xf3lares?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l es el tipo de cambio promedio que ]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea factura m\xe1s en d\xf3lares?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto es todo en d\xf3lares?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea genera m\xe1s ingresos?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto factura Montevideo vs Mercedes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 oficina es m\xe1s rentable?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfC\xf3mo est\xe1 Mercedes este mes?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1nto gast\xf3 Contable?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfQu\xe9 \xe1rea tiene m\xe1s gastos?]
ERROR tests/test_e2e.py::test_pregunta_real_e2e[\xbfCu\xe1l es la facturaci\xf3n de cada \xe1rea?]
ERROR tests/test_e2e.py::TestMetricasPrecision::test_tasa_respuesta_exitosa
ERROR tests/test_e2e.py::TestMetricasPrecision::test_metadata_presente_en_exitosas
ERROR tests/test_e2e.py::TestMetricasPrecision::test_tiempo_respuesta_razonable
ERROR tests/test_integration_real.py::TestOperacionesIntegration::test_crear_ingreso_completo
ERROR tests/test_integration_real.py::TestOperacionesIntegration::test_crear_gasto_completo
ERROR tests/test_integration_real.py::TestOperacionesIntegration::test_crear_retiro_completo
ERROR tests/test_integration_real.py::TestOperacionesIntegration::test_operacion_calcula_monto_usd_correctamente
ERROR tests/test_integration_real.py::TestOperacionesIntegration::test_listar_operaciones_con_filtros
ERROR tests/test_integration_real.py::TestCFOAIIntegration::test_pregunta_simple_retorna_respuesta
ERROR tests/test_integration_real.py::TestCFOAIIntegration::test_pregunta_genera_sql_valido
ERROR tests/test_integration_real.py::TestDatosConsistencia::test_soft_delete_operacion
ERROR tests/test_integration_real.py::TestDatosConsistencia::test_relacion_operacion_area
ERROR tests/test_operacion_service.py::TestCrearOperacionBase::test_crear_operacion_base_ingreso
ERROR tests/test_operacion_service.py::TestCrearOperacionBase::test_crear_operacion_base_gasto
ERROR tests/test_operacion_service.py::TestCrearOperacionBase::test_crear_operacion_base_localidad_normalizada
ERROR tests/test_operacion_service.py::TestCrearIngreso::test_crear_ingreso_uyu
ERROR tests/test_operacion_service.py::TestCrearIngreso::test_crear_ingreso_usd
ERROR tests/test_operacion_service.py::TestCrearGasto::test_crear_gasto_uyu
ERROR tests/test_operacion_service.py::TestCrearGasto::test_crear_gasto_usd
ERROR tests/test_operacion_service.py::TestCrearDistribucion::test_crear_distribucion_5_socios_completa
ERROR tests/test_operacion_service.py::TestCrearDistribucion::test_crear_distribucion_parcial_3_socios
ERROR tests/test_operacion_service.py::TestCrearDistribucion::test_crear_distribucion_detecta_moneda_original
ERROR tests/test_operacion_service.py::TestCrearDistribucion::test_crear_distribucion_no_requiere_area
ERROR tests/test_operacion_service.py::TestCrearDistribucion::test_crear_distribucion_porcentaje_20
ERROR tests/test_operacion_service.py::TestCasosEdge::test_crear_ingreso_sin_cliente
ERROR tests/test_operacion_service.py::TestFiltrosPorLocalidadArea::test_crear_operaciones_diferentes_localidades
= 75 failed, 398 passed, 8 xfailed, 3 xpassed, 21 warnings, 76 errors in 78.28s (0:01:18) =
